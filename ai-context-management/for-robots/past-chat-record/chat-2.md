# New AI chat instructions
_Exported on 1/4/2026 at 21:31:56 PST from Cursor (2.2.44)_

---

**User**

@paste-this-into-new-ai-chats.txt (1-5) 

---

**Cursor**

I see this is a project with an AI context system. Let me get oriented by reading the current work focus files.

Let me also read the operating rules to understand how you'd like me to work with you.

Got it! I'm now oriented on the **stick figure arena shooter** project. Here's my understanding:

## Project Overview
A browser-based Worms-style game with a **notebook paper aesthetic** - stick figures that look like they were doodled on crumpled paper. Built with Phaser 3.

## Current State
The playable prototype is working:
- Player movement (arrows) and shooting (mouse click)
- Red stick figure enemies on platforms
- Level progression with 5 mixed layouts cycling through
- 15 platform shapes in the library
- Water hazard at bottom, walls on sides
- Hand-drawn aesthetic throughout

## Where We Left Off
The wishlist for visual refinements:
1. Reduce character size to half
2. Reduce water height to half  
3. Simplify water to just one line for surface
4. Raise wall bottom edges (like in `example-map.png`)
5. Tweak platform shapes/sizes/layouts/locations

---

**What would you like to work on?** I can tackle items from the wishlist, or if you have something else in mind, let me know!

---

**User**

lets start working through the wishlist

---

**Cursor**

Let's do it! I'll set up the tasks and start with the first one - reducing character size.

Looking at the code, I can see:
- **Player** (lines 149-175): stick figure drawn at 12x22 pixels
- **Enemy** (lines 227-253): same dimensions as player

To halve the character size, I'll scale down all the drawing coordinates and the final texture size. I'll keep the line width readable (going from 2 to 1.5 pixels).

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 840);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 840);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 840);
        wallTexture.generateTexture('wall', 50, 840);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 420, 'wall');   // Left wall
        this.walls.create(673, 420, 'wall');  // Right wall
        
        
        // === WATER HAZARD (hand-drawn style) ===
        const waterGraphics = this.add.graphics();
        
        // Light blue fill for water body
        waterGraphics.fillStyle(0x89CFF0, 0.4);  // Light blue, semi-transparent
        waterGraphics.fillRect(0, 845, 700, 60);
        
        // Draw wavy water line (hand-drawn style)
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 845);
        
        // Create wavy line across the top of water
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 845 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Second wavy line for more doodled feel
        waterGraphics.lineStyle(1.5, 0x4A90D9);
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 855);
        for (let x = 0; x <= 700; x += 12) {
            const waveY = 855 + Math.sin(x * 0.06 + 1) * 3 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection
        this.waterZone = this.add.zone(350, 870, 700, 60);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            this.createSketchyShape(name, data);
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - half size) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs (scaled to half)
        // Head (circle)
        playerGraphics.strokeCircle(3, 2, 1.5);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(3, 3.5);
        playerGraphics.lineTo(3, 7);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1, 5);
        playerGraphics.lineTo(5, 5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(3, 7);
        playerGraphics.lineTo(1.5, 10);
        playerGraphics.moveTo(3, 7);
        playerGraphics.lineTo(4.5, 10);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 6, 11);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(2, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player
        // Head (circle)
        enemyGraphics.strokeCircle(6, 4, 3);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(6, 7);
        enemyGraphics.lineTo(6, 14);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(2, 10);
        enemyGraphics.lineTo(10, 10);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(6, 14);
        enemyGraphics.lineTo(3, 20);
        enemyGraphics.moveTo(6, 14);
        enemyGraphics.lineTo(9, 20);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 12, 22);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 840);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 840);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 840);
        wallTexture.generateTexture('wall', 50, 840);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 420, 'wall');   // Left wall
        this.walls.create(673, 420, 'wall');  // Right wall
        
        
        // === WATER HAZARD (hand-drawn style) ===
        const waterGraphics = this.add.graphics();
        
        // Light blue fill for water body
        waterGraphics.fillStyle(0x89CFF0, 0.4);  // Light blue, semi-transparent
        waterGraphics.fillRect(0, 845, 700, 60);
        
        // Draw wavy water line (hand-drawn style)
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 845);
        
        // Create wavy line across the top of water
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 845 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Second wavy line for more doodled feel
        waterGraphics.lineStyle(1.5, 0x4A90D9);
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 855);
        for (let x = 0; x <= 700; x += 12) {
            const waveY = 855 + Math.sin(x * 0.06 + 1) * 3 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection
        this.waterZone = this.add.zone(350, 870, 700, 60);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            this.createSketchyShape(name, data);
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - half size) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs (scaled to half)
        // Head (circle)
        playerGraphics.strokeCircle(3, 2, 1.5);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(3, 3.5);
        playerGraphics.lineTo(3, 7);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1, 5);
        playerGraphics.lineTo(5, 5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(3, 7);
        playerGraphics.lineTo(1.5, 10);
        playerGraphics.moveTo(3, 7);
        playerGraphics.lineTo(4.5, 10);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 6, 11);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - half size) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player (scaled to half)
        // Head (circle)
        enemyGraphics.strokeCircle(3, 2, 1.5);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(3, 3.5);
        enemyGraphics.lineTo(3, 7);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1, 5);
        enemyGraphics.lineTo(5, 5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(3, 7);
        enemyGraphics.lineTo(1.5, 10);
        enemyGraphics.moveTo(3, 7);
        enemyGraphics.lineTo(4.5, 10);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 6, 11);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
y: plat.y - shapeData.height / 2 - 15  // Above the platform
```

Characters are now half size. Let me update the todo and move to the next item - reducing water height.

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 840);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 840);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 840);
        wallTexture.generateTexture('wall', 50, 840);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 420, 'wall');   // Left wall
        this.walls.create(673, 420, 'wall');  // Right wall
        
        
        // === WATER HAZARD (hand-drawn style - reduced height) ===
        const waterGraphics = this.add.graphics();
        
        // Light blue fill for water body (half the height: 30px instead of 60px)
        waterGraphics.fillStyle(0x89CFF0, 0.4);  // Light blue, semi-transparent
        waterGraphics.fillRect(0, 870, 700, 30);
        
        // Draw wavy water line (hand-drawn style)
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the top of water
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Second wavy line for more doodled feel
        waterGraphics.lineStyle(1.5, 0x4A90D9);
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 880);
        for (let x = 0; x <= 700; x += 12) {
            const waveY = 880 + Math.sin(x * 0.06 + 1) * 3 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (adjusted for new position)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            this.createSketchyShape(name, data);
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - half size) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs (scaled to half)
        // Head (circle)
        playerGraphics.strokeCircle(3, 2, 1.5);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(3, 3.5);
        playerGraphics.lineTo(3, 7);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1, 5);
        playerGraphics.lineTo(5, 5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(3, 7);
        playerGraphics.lineTo(1.5, 10);
        playerGraphics.moveTo(3, 7);
        playerGraphics.lineTo(4.5, 10);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 6, 11);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - half size) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player (scaled to half)
        // Head (circle)
        enemyGraphics.strokeCircle(3, 2, 1.5);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(3, 3.5);
        enemyGraphics.lineTo(3, 7);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1, 5);
        enemyGraphics.lineTo(5, 5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(3, 7);
        enemyGraphics.lineTo(1.5, 10);
        enemyGraphics.moveTo(3, 7);
        enemyGraphics.lineTo(4.5, 10);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 6, 11);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Water height halved. Now let's simplify the water to just one line (removing the fill and second wave line).

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 840);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 840);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 840);
        wallTexture.generateTexture('wall', 50, 840);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 420, 'wall');   // Left wall
        this.walls.create(673, 420, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            this.createSketchyShape(name, data);
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - half size) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs (scaled to half)
        // Head (circle)
        playerGraphics.strokeCircle(3, 2, 1.5);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(3, 3.5);
        playerGraphics.lineTo(3, 7);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1, 5);
        playerGraphics.lineTo(5, 5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(3, 7);
        playerGraphics.lineTo(1.5, 10);
        playerGraphics.moveTo(3, 7);
        playerGraphics.lineTo(4.5, 10);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 6, 11);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - half size) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player (scaled to half)
        // Head (circle)
        enemyGraphics.strokeCircle(3, 2, 1.5);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(3, 3.5);
        enemyGraphics.lineTo(3, 7);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1, 5);
        enemyGraphics.lineTo(5, 5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(3, 7);
        enemyGraphics.lineTo(1.5, 10);
        enemyGraphics.moveTo(3, 7);
        enemyGraphics.lineTo(4.5, 10);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 6, 11);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Water simplified. Now for the walls - let me check the reference image to see how the walls should look.

---

**User**

wait wait wait. one wishlist item at a time

---

**Cursor**

Got it! I got ahead of myself there. 

I've already made changes for the first three items:
1. âœ… Character size halved
2. âœ… Water height halved  
3. âœ… Water simplified to one line

Would you like to:
- **

---

**User**

dont undo but for future reference thats the pacing im looking for

---

**Cursor**

Understood! One change at a time, test it, then move on. I'll pace myself going forward.

So we're at:
1. âœ… Character size halved
2. âœ… Water height halved  
3. âœ… Water simplified to one line

Want to test these now? You can run `python3 -m http.server 8000` and check it out. When you're ready, we'll tackle **#4: Raise wall bottom edges**.

---

**User**

lets change character size to 1.5 times what it is now. 

---

**Cursor**

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 840);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 840);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 840);
        wallTexture.generateTexture('wall', 50, 840);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 420, 'wall');   // Left wall
        this.walls.create(673, 420, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            this.createSketchyShape(name, data);
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs
        // Head (circle)
        playerGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 5.25);
        playerGraphics.lineTo(4.5, 10.5);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1.5, 7.5);
        playerGraphics.lineTo(7.5, 7.5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(2.25, 15);
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(6.75, 15);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 9, 17);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - half size) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player (scaled to half)
        // Head (circle)
        enemyGraphics.strokeCircle(3, 2, 1.5);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(3, 3.5);
        enemyGraphics.lineTo(3, 7);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1, 5);
        enemyGraphics.lineTo(5, 5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(3, 7);
        enemyGraphics.lineTo(1.5, 10);
        enemyGraphics.moveTo(3, 7);
        enemyGraphics.lineTo(4.5, 10);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 6, 11);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 840);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 840; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 840);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 840);
        wallTexture.generateTexture('wall', 50, 840);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 420, 'wall');   // Left wall
        this.walls.create(673, 420, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            this.createSketchyShape(name, data);
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs
        // Head (circle)
        playerGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 5.25);
        playerGraphics.lineTo(4.5, 10.5);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1.5, 7.5);
        playerGraphics.lineTo(7.5, 7.5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(2.25, 15);
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(6.75, 15);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 9, 17);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player
        // Head (circle)
        enemyGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 5.25);
        enemyGraphics.lineTo(4.5, 10.5);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1.5, 7.5);
        enemyGraphics.lineTo(7.5, 7.5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(2.25, 15);
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(6.75, 15);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 9, 17);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Done! Characters are now 1.5x bigger (9x17 pixels, which is 75% of the original size). Refresh to see the change.

---

**User**

lets raise the height of the bottom of the walls a little more

---

**Cursor**

Currently walls go down to y=840. I'll raise them to stop higher - let's try y=750 (leaving a gap above the water).

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line (raised bottom)
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 750; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 750);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line (raised bottom)
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 750; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 750);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 750);
        wallTexture.generateTexture('wall', 50, 750);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 375, 'wall');   // Left wall
        this.walls.create(673, 375, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            this.createSketchyShape(name, data);
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs
        // Head (circle)
        playerGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 5.25);
        playerGraphics.lineTo(4.5, 10.5);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1.5, 7.5);
        playerGraphics.lineTo(7.5, 7.5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(2.25, 15);
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(6.75, 15);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 9, 17);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player
        // Head (circle)
        enemyGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 5.25);
        enemyGraphics.lineTo(4.5, 10.5);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1.5, 7.5);
        enemyGraphics.lineTo(7.5, 7.5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(2.25, 15);
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(6.75, 15);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 9, 17);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Done! Walls now stop at y=750 (was 840), leaving a gap above the water. Refresh to check it out.

---

**User**

lets aim for halfway between where they were and where they are. and then have a horizontal line to the edge of the page on the bottom to close them off

---

**Cursor**

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 795);
        wallTexture.generateTexture('wall', 50, 795);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            this.createSketchyShape(name, data);
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs
        // Head (circle)
        playerGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 5.25);
        playerGraphics.lineTo(4.5, 10.5);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1.5, 7.5);
        playerGraphics.lineTo(7.5, 7.5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(2.25, 15);
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(6.75, 15);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 9, 17);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player
        // Head (circle)
        enemyGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 5.25);
        enemyGraphics.lineTo(4.5, 10.5);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1.5, 7.5);
        enemyGraphics.lineTo(7.5, 7.5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(2.25, 15);
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(6.75, 15);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 9, 17);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Done! Walls now stop at y=795 with horizontal lines closing them off to the page edges. Refresh to see it.

---

**User**

ok looks good. now whats next on the wishlist

---

**Cursor**

Done with 1-4! âœ…

**Last item: #5 - Tweak platform shapes/sizes/layouts/locations**

This one's more open-ended. What would you like to adjust?
- Make platforms smaller/larger?
- Change specific shapes?
- Adjust the level layouts?
- Move platforms around?

Let me know what's bugging you about the current setup, or if you want me to pull up the reference images to compare.

---

**User**

yeah, this is gonna be tough to interpret maybe. but do you see how in the example map there is basically a gap between the platforms and the walls so a character could drop straighit down near the walls?

---

**Cursor**

Let me check the reference images to see what you mean.

Yes! I see it clearly now. In the reference, there's a clear vertical corridor along both walls - platforms are kept away from the edges, so you could drop straight down near a wall without hitting anything.

Let me check the current layouts to see how close platforms are to the walls.

Yes! I see exactly what you mean. In the reference, there's a clear ~60-80px vertical corridor along each wall where you could drop straight down.

Looking at the current layouts, many platforms are placed at x: 100-150 (too close to left wall at x=55) and x: 550-600 (too close to right wall at x=645).

I'll adjust the layouts to keep platforms more toward the center, creating those drop corridors. Want me to:
1. Shift all the edge platforms inward to create the gaps?

This will touch all 5 layouts in `PlatformShapes.js`.

---

**User**

whatever you think is the best method

---

**Cursor**

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    }
};


/**
 * Predefined level layouts - all mixed variety of shapes
 * Canvas is 700x900, water at y=870, walls at x=55 and x=645
 * Drop corridors: keep platforms away from walls (x: 180-520 for centers)
 * This leaves ~125px vertical drop zones along each wall
 */
const LEVEL_LAYOUTS = [
    // Layout 1
    {
        name: "mix1",
        platforms: [
            // Bottom (y: 780-810)
            { shape: 'flatLong', x: 220, y: 800 },
            { shape: 'blockShort', x: 360, y: 780 },
            { shape: 'flatMedium', x: 480, y: 800 },
            // Lower-mid (y: 680-720)
            { shape: 'lShapeDownRight', x: 200, y: 710 },
            { shape: 'flatSmall', x: 380, y: 685 },
            { shape: 'blockWide', x: 490, y: 700 },
            // Mid (y: 570-610)
            { shape: 'flatMedium', x: 210, y: 595 },
            { shape: 'tShape', x: 350, y: 580 },
            { shape: 'flatLong', x: 460, y: 605 },
            // Upper-mid (y: 460-500)
            { shape: 'pillar', x: 220, y: 490 },
            { shape: 'flatMedium', x: 360, y: 490 },
            { shape: 'lShapeDownLeft', x: 480, y: 500 },
            // Upper (y: 360-400)
            { shape: 'flatSmall', x: 200, y: 390 },
            { shape: 'blockShort', x: 350, y: 380 },
            { shape: 'flatMedium', x: 480, y: 400 },
            // Top (y: 250-300)
            { shape: 'flatMedium', x: 230, y: 285 },
            { shape: 'flatSmall', x: 410, y: 260 },
            { shape: 'flatSmall', x: 500, y: 295 },
            // Very top (y: 130-180)
            { shape: 'flatSmall', x: 200, y: 170 },
            { shape: 'flatLong', x: 360, y: 155 },
            { shape: 'flatTiny', x: 500, y: 180 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom
            { shape: 'flatMedium', x: 200, y: 800 },
            { shape: 'rock', x: 320, y: 785 },
            { shape: 'flatLong', x: 460, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 200, y: 700 },
            { shape: 'bumpyWide', x: 350, y: 710 },
            { shape: 'flatSmall', x: 500, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 200, y: 595 },
            { shape: 'cupShape', x: 300, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 510, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 200, y: 490 },
            { shape: 'flatLong', x: 380, y: 475 },
            { shape: 'flatTiny', x: 510, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 230, y: 375 },
            { shape: 'pillar', x: 400, y: 385 },
            { shape: 'flatSmall', x: 500, y: 360 },
            // Top
            { shape: 'flatSmall', x: 200, y: 260 },
            { shape: 'flatMedium', x: 350, y: 270 },
            { shape: 'lShapeDownLeft', x: 480, y: 260 },
            // Very top
            { shape: 'flatLong', x: 280, y: 155 },
            { shape: 'flatSmall', x: 480, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom
            { shape: 'flatLong', x: 220, y: 800 },
            { shape: 'lShapeDownLeft', x: 400, y: 775 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 210, y: 695 },
            { shape: 'notchedBlock', x: 360, y: 700 },
            { shape: 'pillar', x: 500, y: 715 },
            // Mid
            { shape: 'blockWide', x: 200, y: 595 },
            { shape: 'flatSmall', x: 340, y: 580 },
            { shape: 'flatLong', x: 460, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 200, y: 490 },
            { shape: 'blockShort', x: 310, y: 495 },
            { shape: 'lShapeDownRight', x: 450, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 220, y: 385 },
            { shape: 'flatSmall', x: 380, y: 375 },
            { shape: 'flatMedium', x: 490, y: 390 },
            // Top
            { shape: 'flatSmall', x: 200, y: 270 },
            { shape: 'tShape', x: 340, y: 260 },
            { shape: 'flatMedium', x: 480, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 290, y: 155 },
            { shape: 'flatTiny', x: 470, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom
            { shape: 'blockShort', x: 190, y: 780 },
            { shape: 'flatLong', x: 340, y: 800 },
            { shape: 'lShapeDownRight', x: 480, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 210, y: 685 },
            { shape: 'tShape', x: 350, y: 680 },
            { shape: 'flatMedium', x: 480, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 200, y: 580 },
            { shape: 'rock', x: 350, y: 570 },
            { shape: 'bumpyWide', x: 460, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 200, y: 475 },
            { shape: 'blockTall', x: 340, y: 490 },
            { shape: 'flatMedium', x: 480, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 200, y: 375 },
            { shape: 'cupShape', x: 360, y: 360 },
            { shape: 'flatSmall', x: 500, y: 375 },
            // Top
            { shape: 'flatMedium', x: 240, y: 270 },
            { shape: 'flatSmall', x: 420, y: 260 },
            { shape: 'pillar', x: 510, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 200, y: 155 },
            { shape: 'flatLong', x: 380, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom
            { shape: 'flatMedium', x: 200, y: 800 },
            { shape: 'pillar', x: 340, y: 770 },
            { shape: 'flatMedium', x: 460, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 200, y: 700 },
            { shape: 'flatLong', x: 380, y: 695 },
            { shape: 'flatTiny', x: 510, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 200, y: 595 },
            { shape: 'lShapeDownRight', x: 320, y: 595 },
            { shape: 'blockShort', x: 490, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 210, y: 490 },
            { shape: 'flatSmall', x: 370, y: 475 },
            { shape: 'notchedBlock', x: 490, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 210, y: 385 },
            { shape: 'flatMedium', x: 370, y: 375 },
            { shape: 'flatSmall', x: 500, y: 390 },
            // Top
            { shape: 'flatSmall', x: 200, y: 270 },
            { shape: 'blockShort', x: 350, y: 265 },
            { shape: 'flatMedium', x: 480, y: 285 },
            // Very top
            { shape: 'flatLong', x: 290, y: 170 },
            { shape: 'flatTiny', x: 480, y: 155 }
        ]
    }
];

```

Done! I shifted all platforms inward:
- **Left side:** platforms now start around x=190-200 (was 100-150)
- **Right side:** platforms now end around x=480-510 (was 540-600)

This creates ~125px vertical drop corridors along both walls. Refresh and test it out!

---

**User**

narrow drop corridor width to 1/3rd that. make sure player character spawns on an existing platform

---

**Cursor**

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    }
};


/**
 * Predefined level layouts - all mixed variety of shapes
 * Canvas is 700x900, water at y=870, walls at x=55 and x=645
 * Drop corridors: ~40px gap along each wall
 * First platform in each layout is the player spawn point
 */
const LEVEL_LAYOUTS = [
    // Layout 1
    {
        name: "mix1",
        platforms: [
            // Bottom (y: 780-810) - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'blockShort', x: 350, y: 780 },
            { shape: 'flatMedium', x: 540, y: 800 },
            // Lower-mid (y: 680-720)
            { shape: 'lShapeDownRight', x: 140, y: 710 },
            { shape: 'flatSmall', x: 350, y: 685 },
            { shape: 'blockWide', x: 550, y: 700 },
            // Mid (y: 570-610)
            { shape: 'flatMedium', x: 150, y: 595 },
            { shape: 'tShape', x: 350, y: 580 },
            { shape: 'flatLong', x: 520, y: 605 },
            // Upper-mid (y: 460-500)
            { shape: 'pillar', x: 160, y: 490 },
            { shape: 'flatMedium', x: 350, y: 490 },
            { shape: 'lShapeDownLeft', x: 540, y: 500 },
            // Upper (y: 360-400)
            { shape: 'flatSmall', x: 140, y: 390 },
            { shape: 'blockShort', x: 350, y: 380 },
            { shape: 'flatMedium', x: 550, y: 400 },
            // Top (y: 250-300)
            { shape: 'flatMedium', x: 170, y: 285 },
            { shape: 'flatSmall', x: 380, y: 260 },
            { shape: 'flatSmall', x: 560, y: 295 },
            // Very top (y: 130-180)
            { shape: 'flatSmall', x: 140, y: 170 },
            { shape: 'flatLong', x: 350, y: 155 },
            { shape: 'flatTiny', x: 570, y: 180 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Drop corridors narrowed to ~40px (was ~125px). Platforms now range from x~130 to x~570. 

The first platform in each layout is a bottom-row spawn point - the existing code already spawns the player above the first platform in the layout, so you should land on it. Refresh and test!

---

**User**

ok the next thing is tougher to describe. size and shape of the types of platforms and where they can appear. should we refactor to make this more interpretable or what?

---

**Cursor**

Good question. Let me understand what you're trying to control before we refactor.

Currently we have:
- **15 shapes** with fixed sizes in `PLATFORM_SHAPES`
- **5 layouts** with hand-placed platforms

What's bothering you? For example:
1. **Some shapes are too big/small?** â†’ We could add a scale parameter when placing them
2. **Want certain shapes only in certain areas?** (e.g., "tall blocks only on right side") â†’ We could add zone rules
3. **Want to tweak individual shape dimensions?** â†’ The shapes themselves could be adjusted
4. **Hard to visualize what's what?** â†’ We could add better naming/categories

What's the actual thing you're trying to achieve? Once I understand the goal, I can suggest the simplest refactor that gets you there.

---

**User**

i want certain shapes in certain areas. a certain pattern. like basically the image i shared shows kind of a bias to the long horizontal pieces being on the two halves of the map. you see what i mean? with like somewhat of vertical stacked layers? so there are like two halves to the map and not exactly but sort of unique layers? and then the middle area of the map is more open but kind of has random smaller platforms and different heights? and all the longer platforms near the walls kind of go to the same distance from the walls? can you interpret/understand and try to represent all those things in code? like is that even possible?

---

**Cursor**

```javascript
const LAYOUT_ZONES = {
    LEFT: { xMin: 100, xMax: 220 },
    CENTER: { xMin: 280, xMax: 420 },
    RIGHT: { xMin: 480, xMax: 600 }
};

const ZONE_SHAPES = {
    LEFT: ['flatLong', 'flatMedium', 'lShapeDownRight', 'blockWide'],
    CENTER: ['flatSmall', 'flatTiny', 'rock', 'tShape', 'pillar', 'cupShape'],
    RIGHT: ['flatLong', 'flatMedium', 'lShapeDownLeft', 'blockWide']


};

const LAYER_HEIGHTS = [800, 700, 600, 500, 400, 300, 200]; // y positions
```

Yes, I totally see what you mean from the reference image! Let me break down the pattern:

**Left side:** Stacked horizontal tiers of long/medium platforms, all aligned to a similar x-position near the left wall

**Right side:** Same thing - stacked tiers, aligned near the right wall

**Center:** More open/sparse - smaller random shapes (rocks, T-shapes, tiny platforms) at varied heights, not aligned to the side tiers

**Wall alignment:** The long platforms on each side all extend to roughly the same distance from their wall

This is totally doable. I can either:

**Option A: Restructure the layouts manually** - Rewrite the 5 layouts following this pattern. Simpler, you can see exactly what's placed where.

**Option B: Create a zone-based generator** - Define rules like "LEFT zone gets flatLong/flatMedium at these y-tiers, CENTER gets small scattered pieces" and generate layouts from rules. More flexible but more complex.

I'd suggest **Option A first** - let me rewrite one layout following this pattern so you can see if I'm interpreting it right. If it looks good, I'll do the rest. If we need to tweak, it's easier to adjust manual layouts than debug a generator.

Want me to try Layout 1 with this structure?

---

**User**

ok yea try a first to see if youo're interpreting right

---

**Cursor**

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    }
};


/**
 * Predefined level layouts - all mixed variety of shapes
 * Canvas is 700x900, water at y=870, walls at x=55 and x=645
 * Drop corridors: ~40px gap along each wall
 * First platform in each layout is the player spawn point
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (stacked tiers at x~130) ===
            { shape: 'flatLong', x: 130, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatMedium', x: 130, y: 680 },  // Tier 2
            { shape: 'flatLong', x: 130, y: 580 },    // Tier 3
            { shape: 'flatMedium', x: 130, y: 480 },  // Tier 4
            { shape: 'flatLong', x: 130, y: 380 },    // Tier 5
            { shape: 'flatMedium', x: 130, y: 280 },  // Tier 6
            { shape: 'flatSmall', x: 130, y: 180 },   // Tier 7
            
            // === RIGHT COLUMN (stacked tiers at x~570) ===
            { shape: 'flatLong', x: 570, y: 780 },    // Tier 1
            { shape: 'flatMedium', x: 570, y: 680 },  // Tier 2
            { shape: 'flatLong', x: 570, y: 580 },    // Tier 3
            { shape: 'flatMedium', x: 570, y: 480 },  // Tier 4
            { shape: 'flatLong', x: 570, y: 380 },    // Tier 5
            { shape: 'flatMedium', x: 570, y: 280 },  // Tier 6
            { shape: 'flatSmall', x: 570, y: 180 },   // Tier 7
            
            // === CENTER (scattered small shapes, offset heights) ===
            { shape: 'rock', x: 350, y: 730 },
            { shape: 'flatSmall', x: 320, y: 620 },
            { shape: 'tShape', x: 380, y: 520 },
            { shape: 'flatTiny', x: 340, y: 420 },
            { shape: 'pillar', x: 360, y: 320 },
            { shape: 'cupShape', x: 350, y: 220 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Layout 1 now has:

**Left column (x=130):** 7 stacked tiers of long/medium platforms (y: 780, 680, 580, 480, 380, 280, 180)

**Right column (x=570):** Mirror of left - same 7 tiers

**Center (x~320-380):** 6 scattered small shapes (rock, flatSmall, tShape, flatTiny, pillar, cupShape) at heights *offset* from the tiers (y: 730, 620, 520, 420, 320, 220)

Refresh and check if this matches what you're picturing. The other 4 layouts still have the old structure, so switch to a different level if you want to compare.

---

**User**

i took a screenshot and put it in reference called layout-ref-1. i think the idea is sort of right! definitely could use fine tuning but its a great start. what should we do next? option b from earlier and then tune? or tune first?

---

**Cursor**

Let me see the screenshot to understand what needs tuning.

Nice! I can see the structure is working - two columns with an open center. Looking at it vs the original reference, here's what I'd tune:

**Current issues:**
1. Too symmetric - left and right are perfect mirrors
2. Every tier has a platform on both sides - original has some gaps
3. Side platforms all at exact same x - could vary slightly
4. Center pieces are very linear down the middle

**My recommendation: Tune first.**

Once we nail down what makes one layout feel right, we'll know the actual rules to encode. Building a generator before we understand the rules = guessing.

Let me tweak Layout 1 with:
- Break the perfect symmetry (different shapes on each side)
- Skip some tiers on each side (not every row has both)
- Vary the side x-positions slightly
- Spread center pieces more organically

Want me to do that pass?

---

**User**

i like all 4 of those suggestions. after that stop and let me check but after that lets add a refresh button or restart or something so i can test multiple layouts

---

**Cursor**

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    }
};


/**
 * Predefined level layouts - all mixed variety of shapes
 * Canvas is 700x900, water at y=870, walls at x=55 and x=645
 * Drop corridors: ~40px gap along each wall
 * First platform in each layout is the player spawn point
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (asymmetric, organic)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (varied x, some gaps) ===
            { shape: 'flatLong', x: 135, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatMedium', x: 125, y: 670 },  // Tier 2
            // skip tier 3 on left
            { shape: 'flatLong', x: 140, y: 470 },    // Tier 4
            { shape: 'flatMedium', x: 120, y: 360 },  // Tier 5
            // skip tier 6 on left
            { shape: 'flatSmall', x: 130, y: 170 },   // Tier 7
            
            // === RIGHT COLUMN (different shapes, varied x, some gaps) ===
            { shape: 'flatMedium', x: 565, y: 760 },  // Tier 1 (slightly higher)
            // skip tier 2 on right
            { shape: 'flatLong', x: 575, y: 570 },    // Tier 3
            { shape: 'flatMedium', x: 555, y: 460 },  // Tier 4
            { shape: 'flatLong', x: 570, y: 350 },    // Tier 5
            { shape: 'flatSmall', x: 580, y: 250 },   // Tier 6
            // skip tier 7 on right
            
            // === CENTER (spread out, varied positions) ===
            { shape: 'rock', x: 310, y: 720 },
            { shape: 'flatSmall', x: 400, y: 640 },
            { shape: 'tShape', x: 340, y: 530 },
            { shape: 'flatTiny', x: 420, y: 400 },
            { shape: 'pillar', x: 300, y: 290 },
            { shape: 'cupShape', x: 380, y: 200 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Layout 1 now has:
- **Left:** 5 platforms (skips tiers 3 & 6), x varies 120-140
- **Right:** 5 platforms (skips tiers 2 & 7), x varies 555-580, different shapes
- **Center:** Spread wider (x: 300-420 instead of 320-380)

Refresh and check it out. Let me know how it feels, then I'll add the restart button.

---

**User**

add restart button. after that i think we do longer platforms and/or less gap in the middle. and denser vertically/more platforms/layers. but stop between restart button and that

---

**Cursor**

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 795);
        wallTexture.generateTexture('wall', 50, 795);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            this.createSketchyShape(name, data);
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs
        // Head (circle)
        playerGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 5.25);
        playerGraphics.lineTo(4.5, 10.5);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1.5, 7.5);
        playerGraphics.lineTo(7.5, 7.5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(2.25, 15);
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(6.75, 15);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 9, 17);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player
        // Head (circle)
        enemyGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 5.25);
        enemyGraphics.lineTo(4.5, 10.5);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1.5, 7.5);
        enemyGraphics.lineTo(7.5, 7.5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(2.25, 15);
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(6.75, 15);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 9, 17);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload layout)
        this.input.keyboard.on('keydown-R', () => {
            this.scene.restart();
        });
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Done! Press **R** to restart the level. It fully reloads the scene so you can see the layout fresh (the hand-drawn wobbles will regenerate too).

Refresh and test it out. When you're ready, let me know about the longer platforms / less gap / more density tweaks.

---

**User**

it doesnt appear to do anyting that i can see

---

**Cursor**

Let me fix that - might be an issue with how the key listener is set up.

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 795);
        wallTexture.generateTexture('wall', 50, 795);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            this.createSketchyShape(name, data);
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs
        // Head (circle)
        playerGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 5.25);
        playerGraphics.lineTo(4.5, 10.5);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1.5, 7.5);
        playerGraphics.lineTo(7.5, 7.5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(2.25, 15);
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(6.75, 15);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 9, 17);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player
        // Head (circle)
        enemyGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 5.25);
        enemyGraphics.lineTo(4.5, 10.5);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1.5, 7.5);
        enemyGraphics.lineTo(7.5, 7.5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(2.25, 15);
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(6.75, 15);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 9, 17);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 795);
        wallTexture.generateTexture('wall', 50, 795);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            this.createSketchyShape(name, data);
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs
        // Head (circle)
        playerGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 5.25);
        playerGraphics.lineTo(4.5, 10.5);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1.5, 7.5);
        playerGraphics.lineTo(7.5, 7.5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(2.25, 15);
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(6.75, 15);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 9, 17);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player
        // Head (circle)
        enemyGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 5.25);
        enemyGraphics.lineTo(4.5, 10.5);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1.5, 7.5);
        enemyGraphics.lineTo(7.5, 7.5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(2.25, 15);
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(6.75, 15);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 9, 17);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart();
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Fixed! Now using Phaser's `addKey` + `JustDown` pattern which is more reliable. Refresh and try pressing R - you should see the scene restart (walls and platforms will redraw with fresh wobbles).

---

**User**

ok it sort of works. funny bug here. the gray filling in the platforms stacks and gets darker as i restart. the lines also seem to be getting thicker or overlapping but maybe thats my imagination. once you fix that we should fix the main purpose of the key was to generate a new map. so maybe R is actually useful but G key to generate a new map

---

**Cursor**

Ah classic Phaser texture bug! The textures accumulate because they're not cleaned up on restart. I'll fix that and add the G key for new map.

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 795);
        wallTexture.generateTexture('wall', 50, 795);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        const playerGraphics = this.add.graphics();
        playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
        
        // Simple stick figure: head, body, legs
        // Head (circle)
        playerGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 5.25);
        playerGraphics.lineTo(4.5, 10.5);
        playerGraphics.strokePath();
        // Arms (line across)
        playerGraphics.beginPath();
        playerGraphics.moveTo(1.5, 7.5);
        playerGraphics.lineTo(7.5, 7.5);
        playerGraphics.strokePath();
        // Legs (two lines)
        playerGraphics.beginPath();
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(2.25, 15);
        playerGraphics.moveTo(4.5, 10.5);
        playerGraphics.lineTo(6.75, 15);
        playerGraphics.strokePath();
        
        playerGraphics.generateTexture('player', 9, 17);
        playerGraphics.destroy();
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player
        // Head (circle)
        enemyGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 5.25);
        enemyGraphics.lineTo(4.5, 10.5);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1.5, 7.5);
        enemyGraphics.lineTo(7.5, 7.5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(2.25, 15);
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(6.75, 15);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 9, 17);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart();
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 795);
        wallTexture.generateTexture('wall', 50, 795);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        const bulletGraphics = this.add.graphics();
        bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
        bulletGraphics.beginPath();
        bulletGraphics.moveTo(0, 2);
        bulletGraphics.lineTo(8, 2);
        bulletGraphics.strokePath();
        bulletGraphics.generateTexture('bullet', 10, 4);
        bulletGraphics.destroy();
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player
        // Head (circle)
        enemyGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 5.25);
        enemyGraphics.lineTo(4.5, 10.5);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1.5, 7.5);
        enemyGraphics.lineTo(7.5, 7.5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(2.25, 15);
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(6.75, 15);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 9, 17);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart();
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 795);
        wallTexture.generateTexture('wall', 50, 795);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        const enemyGraphics = this.add.graphics();
        enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
        
        // Same stick figure shape as player
        // Head (circle)
        enemyGraphics.strokeCircle(4.5, 3, 2.25);
        // Body (line down)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 5.25);
        enemyGraphics.lineTo(4.5, 10.5);
        enemyGraphics.strokePath();
        // Arms (line across)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(1.5, 7.5);
        enemyGraphics.lineTo(7.5, 7.5);
        enemyGraphics.strokePath();
        // Legs (two lines)
        enemyGraphics.beginPath();
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(2.25, 15);
        enemyGraphics.moveTo(4.5, 10.5);
        enemyGraphics.lineTo(6.75, 15);
        enemyGraphics.strokePath();
        
        enemyGraphics.generateTexture('enemy', 9, 17);
        enemyGraphics.destroy();
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart();
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures
        const wallTexture = this.add.graphics();
        wallTexture.fillStyle(0x000000, 0);  // Invisible
        wallTexture.fillRect(0, 0, 50, 795);
        wallTexture.generateTexture('wall', 50, 795);
        wallTexture.destroy();
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart();
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart();
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Now let me add the G key for generating a new map, and update the UI text.

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart | G: new map', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart();
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select a random level layout (or use first one for now)
        this.currentLayoutIndex = 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart | G: new map', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart | G: new map', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Done! Now:
- **R** = restart same layout (no texture stacking)
- **G** = generate new map (cycles through layouts 1-5)

Refresh and test. The texture stacking bug should be fixed, and G should cycle through the different layouts.

---

**User**

ah i thought the layouts were random. can you add a layout number that displays on screen for debugging purposes?

---

**Cursor**

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart | G: new map', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Done! Now shows "Layout: 1/5" (etc.) below the enemy counter. The layouts are predefined - G cycles through all 5. Refresh and you'll see it.

---

**User**

ok that works. what was the thing we were going to do.

---

**Cursor**

You wanted to tweak Layout 1 with:

1. **Longer platforms** on the sides (and/or)
2. **Less gap in the middle** - center pieces spread wider
3. **Denser vertically** - more platforms/layers

Ready to do that now?

---

**User**

yes, but i actually wanted that for all layouts. or maybe we should just do that to layout 1 so you can build the generator based off it?

---

**Cursor**

Smart thinking. Let's do **Layout 1 first** to nail down the parameters:
- How long the side platforms should be
- How far center pieces spread
- How many tiers / vertical spacing

Once Layout 1 feels right, those become the rules for a generator that creates all layouts consistently. Way easier than manually tuning 5 layouts.

Let me tweak Layout 1 now - longer side platforms, less center gap, more tiers.

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    }
};


/**
 * Predefined level layouts - all mixed variety of shapes
 * Canvas is 700x900, water at y=870, walls at x=55 and x=645
 * Drop corridors: ~40px gap along each wall
 * First platform in each layout is the player spawn point
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (denser, longer platforms)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (mostly flatLong, tighter vertical spacing ~70px) ===
            { shape: 'flatLong', x: 135, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 125, y: 710 },    // Tier 2
            { shape: 'flatLong', x: 140, y: 640 },    // Tier 3
            { shape: 'flatMedium', x: 130, y: 570 },  // Tier 4
            { shape: 'flatLong', x: 120, y: 500 },    // Tier 5
            { shape: 'flatLong', x: 135, y: 430 },    // Tier 6
            { shape: 'flatMedium', x: 125, y: 360 },  // Tier 7
            { shape: 'flatLong', x: 140, y: 290 },    // Tier 8
            { shape: 'flatMedium', x: 130, y: 220 },  // Tier 9
            { shape: 'flatSmall', x: 125, y: 150 },   // Tier 10
            
            // === RIGHT COLUMN (mostly flatLong, offset y from left) ===
            { shape: 'flatLong', x: 565, y: 760 },    // Tier 1
            { shape: 'flatLong', x: 575, y: 690 },    // Tier 2
            { shape: 'flatMedium', x: 555, y: 620 },  // Tier 3
            { shape: 'flatLong', x: 570, y: 550 },    // Tier 4
            { shape: 'flatLong', x: 560, y: 480 },    // Tier 5
            { shape: 'flatMedium', x: 575, y: 410 },  // Tier 6
            { shape: 'flatLong', x: 565, y: 340 },    // Tier 7
            { shape: 'flatLong', x: 555, y: 270 },    // Tier 8
            { shape: 'flatSmall', x: 570, y: 200 },   // Tier 9
            
            // === CENTER (spread wider x: 250-450, varied y) ===
            { shape: 'rock', x: 280, y: 740 },
            { shape: 'flatSmall', x: 420, y: 670 },
            { shape: 'tShape', x: 300, y: 590 },
            { shape: 'flatTiny', x: 400, y: 520 },
            { shape: 'flatSmall', x: 260, y: 450 },
            { shape: 'pillar', x: 440, y: 380 },
            { shape: 'cupShape', x: 320, y: 310 },
            { shape: 'flatTiny', x: 380, y: 240 },
            { shape: 'rock', x: 350, y: 170 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Layout 1 now has:

**Sides:**
- Left: 10 tiers (was 5), mostly `flatLong`
- Right: 9 tiers, mostly `flatLong`
- Vertical spacing ~70px (was ~100px)

**Center:**
- Spread wider: x: 260-440 (was 300-420)
- 9 pieces (was 6)

Press **R** to see the changes, then let me know how it feels!

---

**User**

we're getting there. how about subtract a couple layers each side

---

**Cursor**

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    }
};


/**
 * Predefined level layouts - all mixed variety of shapes
 * Canvas is 700x900, water at y=870, walls at x=55 and x=645
 * Drop corridors: ~40px gap along each wall
 * First platform in each layout is the player spawn point
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (8 tiers, ~70px spacing) ===
            { shape: 'flatLong', x: 135, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 125, y: 710 },    // Tier 2
            { shape: 'flatLong', x: 140, y: 640 },    // Tier 3
            { shape: 'flatMedium', x: 130, y: 570 },  // Tier 4
            { shape: 'flatLong', x: 120, y: 500 },    // Tier 5
            { shape: 'flatLong', x: 135, y: 430 },    // Tier 6
            { shape: 'flatMedium', x: 125, y: 360 },  // Tier 7
            { shape: 'flatSmall', x: 130, y: 290 },   // Tier 8
            
            // === RIGHT COLUMN (7 tiers, offset y from left) ===
            { shape: 'flatLong', x: 565, y: 760 },    // Tier 1
            { shape: 'flatLong', x: 575, y: 690 },    // Tier 2
            { shape: 'flatMedium', x: 555, y: 620 },  // Tier 3
            { shape: 'flatLong', x: 570, y: 550 },    // Tier 4
            { shape: 'flatLong', x: 560, y: 480 },    // Tier 5
            { shape: 'flatMedium', x: 575, y: 410 },  // Tier 6
            { shape: 'flatSmall', x: 565, y: 340 },   // Tier 7
            
            // === CENTER (spread wider x: 250-450, varied y) ===
            { shape: 'rock', x: 280, y: 740 },
            { shape: 'flatSmall', x: 420, y: 670 },
            { shape: 'tShape', x: 300, y: 590 },
            { shape: 'flatTiny', x: 400, y: 520 },
            { shape: 'flatSmall', x: 260, y: 450 },
            { shape: 'pillar', x: 440, y: 380 },
            { shape: 'cupShape', x: 320, y: 310 },
            { shape: 'flatTiny', x: 380, y: 240 },
            { shape: 'rock', x: 350, y: 170 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Left now has 8 tiers (was 10), right has 7 tiers (was 9). Press R to check it.

---

**User**

can we add slight variation to the vertical position of each of the layers? see the example image? they aren't all aligned perfectly? and make sure we fill the open area on top of the window like before?

---

**Cursor**

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    }
};


/**
 * Predefined level layouts - all mixed variety of shapes
 * Canvas is 700x900, water at y=870, walls at x=55 and x=645
 * Drop corridors: ~40px gap along each wall
 * First platform in each layout is the player spawn point
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (8 tiers, varied y ~70px avg spacing) ===
            { shape: 'flatLong', x: 135, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 125, y: 695 },    // Tier 2 (varied)
            { shape: 'flatLong', x: 140, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 130, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 120, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 135, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 125, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 140, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 130, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (8 tiers, different y offsets than left) ===
            { shape: 'flatLong', x: 565, y: 765 },    // Tier 1
            { shape: 'flatLong', x: 575, y: 680 },    // Tier 2
            { shape: 'flatMedium', x: 555, y: 595 },  // Tier 3
            { shape: 'flatLong', x: 570, y: 530 },    // Tier 4
            { shape: 'flatLong', x: 560, y: 450 },    // Tier 5
            { shape: 'flatMedium', x: 575, y: 375 },  // Tier 6
            { shape: 'flatLong', x: 565, y: 285 },    // Tier 7
            { shape: 'flatSmall', x: 555, y: 200 },   // Tier 8 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Now:
- **Left:** 9 tiers, y values varied (780, 695, 620, 555, 475, 400, 315, 240, 160)
- **Right:** 8 tiers, *different* y values (765, 680, 595, 530, 450, 375, 285, 200)
- **Center:** extends up to y=120

The left and right don't align on the same rows anymore. Press R to check!

---

**User**

very good. lets checkpoint. please very thoroughly document the plain language used to describe the map since we are going to be heavily using that for the eventual generator, right?

---

**Cursor**

Great idea! Let me document everything thoroughly.

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (8 tiers, varied y ~70px avg spacing) ===
            { shape: 'flatLong', x: 135, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 125, y: 695 },    // Tier 2 (varied)
            { shape: 'flatLong', x: 140, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 130, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 120, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 135, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 125, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 140, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 130, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (8 tiers, different y offsets than left) ===
            { shape: 'flatLong', x: 565, y: 765 },    // Tier 1
            { shape: 'flatLong', x: 575, y: 680 },    // Tier 2
            { shape: 'flatMedium', x: 555, y: 595 },  // Tier 3
            { shape: 'flatLong', x: 570, y: 530 },    // Tier 4
            { shape: 'flatLong', x: 560, y: 450 },    // Tier 5
            { shape: 'flatMedium', x: 575, y: 375 },  // Tier 6
            { shape: 'flatLong', x: 565, y: 285 },    // Tier 7
            { shape: 'flatSmall', x: 555, y: 200 },   // Tier 8 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

```markdown
# Current Context for New Chat

## Project Status: Visual Tuning & Layout Generator Design

A stick figure arena shooter built with Phaser 3, styled to look like doodles on crumpled notebook paper. Currently refining the level layout system toward a procedural generator.

## What Works

- **Player movement:** Arrow keys to move left/right, up to jump
- **Shooting:** Click to fire toward mouse cursor
- **Enemies:** Red stick figures placed on platforms, destroyed when shot
- **Level progression:** Complete a level by shooting all enemies, click to continue
- **Level layouts:** 5 layouts that cycle (Layout 1 has new structure, others still old)
- **Platform shape library:** 15 different shapes (flat platforms, L-shapes, blocks, pillars, special shapes)
- **Water hazard:** Single wavy blue line at y=870
- **Walls:** Hand-drawn irregular walls (x=55 left, x=645 right) ending at y=795 with horizontal caps
- **Notebook paper background:** Actual crumpled paper image
- **Hand-drawn aesthetic:** Stick figures (0.75x scale), sketchy platform outlines, pen-stroke bullets
- **Debug controls:** R = restart same layout, G = next layout, Layout counter displayed

## Layout Design System (KEY DOCUMENTATION)

See detailed rules in `PlatformShapes.js` header comment. Summary:

### Three-Zone Structure
The map has three vertical zones based on `reference/example-map.png`:

**LEFT COLUMN (x ~120-145)**
- Stacked horizontal platforms ("tiers")
- Mostly `flatLong` shapes, some `flatMedium`
- ~8-9 tiers, ~70-85px spacing (NOT uniform)
- X varies Â±15px per tier
- First platform = player spawn

**RIGHT COLUMN (x ~555-580)**
- Same concept but NOT symmetric to left
- Different tier count than left (asymmetric)
- Y positions OFFSET from left (don't align)
- X varies per tier

**CENTER ZONE (x ~260-440)**
- Open area with scattered SMALL shapes only
- Types: `rock`, `flatSmall`, `flatTiny`, `tShape`, `pillar`, `cupShape`
- ~8-10 pieces at varied heights
- Sparse, organic feel

### Drop Corridors
- ~40px clear gap along each wall
- Player can drop straight down near walls

### Asymmetry Principles
- Left/right have different tier counts
- Left/right y-positions don't align horizontally
- Center pieces not on grid

## File Structure

```
stick-game-test/
â”œâ”€â”€ index.html                    # Entry point, loads Phaser from CDN
â”œâ”€â”€ js/
â”‚   â”œâ”€â”€ game.js                   # Phaser config (700x900 canvas)
â”‚   â”œâ”€â”€ platforms/
â”‚   â”‚   â””â”€â”€ PlatformShapes.js     # 15 shapes + 5 layouts + LAYOUT RULES DOC
â”‚   â””â”€â”€ scenes/
â”‚       â””â”€â”€ PlayScene.js          # Main gameplay
â”œâ”€â”€ assets/
â”‚   â””â”€â”€ cropped-notebook-page.png # Background image
â”œâ”€â”€ reference/
â”‚   â”œâ”€â”€ example-map.png           # Original layout reference
â”‚   â”œâ”€â”€ example-map-2.png         # With stick figure for scale
â”‚   â””â”€â”€ layout-ref-1.png          # Screenshot of current Layout 1
â”œâ”€â”€ ai-context-management/
â””â”€â”€ README.md
```

## Technical Notes

- Phaser 3.70.0 via CDN
- Canvas: 700x900
- Arcade Physics with gravity (800)
- Walls at x=55 (left) and x=645 (right), end at y=795
- Water line at y=870
- Character size: 9x17 pixels (0.75x original)
- Run with `python3 -m http.server 8000`

## Current Task: Layout Generator

Layout 1 is tuned to match the reference image pattern. Next step is building a generator that can create varied layouts following these documented rules.

## Wishlist Completed âœ“

1. âœ“ Reduce character size (now 0.75x original)
2. âœ“ Reduce water height (now single line at y=870)
3. âœ“ Simplify water to one line
4. âœ“ Raise wall bottom edges (now y=795 with horizontal caps)
5. ðŸ”„ Tweak platform layouts (Layout 1 done, generator next)

## What Doesn't Exist Yet

- Layout generator (using documented rules)
- Grappling gun
- Multiple weapons
- Destructible terrain
- Enemy AI (enemies are static)
- Lives/game over system
- Sound effects

## Recent Changes (This Session)

1. Reduced character size to 0.75x original (9x17 pixels)
2. Simplified water to single wavy line at y=870
3. Raised wall bottoms to y=795 with horizontal line caps to page edge
4. Adjusted platform layouts for ~40px drop corridors along walls
5. Redesigned Layout 1 with three-zone structure (left column, right column, open center)
6. Added asymmetry: varied tier counts, non-aligned y positions
7. Added R key (restart) and G key (next layout)
8. Added layout number display for debugging
9. Fixed texture stacking bug on restart
10. Documented layout design rules in PlatformShapes.js

## Known Issues

- Layouts 2-5 still have old structure (need generator or manual update)
- All else working as expected

```

```markdown
# Current Work Focus

Layout 1 tuned to match reference image pattern. Three-zone structure documented (left column, right column, open center). Ready to build procedural layout generator using documented rules.

- **Project Goal:** Build a browser-based stick figure arena shooter with random level generation (Worms-style vibes, notebook paper aesthetic)

- **Intermediate Goal:** Create a procedural layout generator that produces varied maps following the established three-zone pattern

- **Current Task:** Build generator using Layout 1 as the template and the documented rules in PlatformShapes.js

```

**Checkpoint complete!** Here's what's documented:

### In `PlatformShapes.js` (detailed header comment):
- Canvas & boundary specs (700x900, walls, water, playable range)
- **Three-zone structure** with exact x-ranges and shape types
- **Left column rules**: x ~120-145, flatLong/flatMedium, 8-9 tiers, ~70-85px varied spacing
- **Right column rules**: x ~555-580, same shapes, different tier count, y-offsets don't align with left
- **Center zone rules**: x ~260-440, small shapes only (rock, flatSmall, flatTiny, tShape, pillar, cupShape), sparse/organic
- **Drop corridors**: ~40px gap along walls
- **Asymmetry principles**: different tier counts, non-aligned y positions

### In `current-context-for-new-chat.md`:
- Full project status and what works
- Layout design system summary
- All recent changes from this session
- File structure

### In `current-work-focus.md`:
- Updated to reflect generator as next task

Ready for the generator when you are!

---

**User**

we're getting there. i want to make more tweaks first. the gap betwen the walls and platforms is actually not consistent. if you see my image it is pretty close to exactly the same distance. we should have that level of variability in that stat

---

**Cursor**

Got it - you want the platforms on each side to form a consistent edge (like the reference), not wobble inward/outward. Let me standardize the x positions.

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (consistent x=130, varied y ~70px avg spacing) ===
            { shape: 'flatLong', x: 130, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 130, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 130, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 130, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 130, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 130, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 130, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 130, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 130, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (consistent x=570, different y offsets than left) ===
            { shape: 'flatLong', x: 570, y: 765 },    // Tier 1
            { shape: 'flatLong', x: 570, y: 680 },    // Tier 2
            { shape: 'flatMedium', x: 570, y: 595 },  // Tier 3
            { shape: 'flatLong', x: 570, y: 530 },    // Tier 4
            { shape: 'flatLong', x: 570, y: 450 },    // Tier 5
            { shape: 'flatMedium', x: 570, y: 375 },  // Tier 6
            { shape: 'flatLong', x: 570, y: 285 },    // Tier 7
            { shape: 'flatSmall', x: 570, y: 200 },   // Tier 8 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Now:
- **Left column:** all at x=130 (consistent edge)
- **Right column:** all at x=570 (consistent edge)

Press R to check - the platforms should form straight vertical columns along each side now.

---

**User**

you're stlll working on layout 1? there is not a consistent width "hole" or whatever on each side between the wall and platforms

---

**Cursor**

You're right! The gap varies because the platforms have different widths but I'm centering them all at the same x. Let me fix it so the **edge closest to the wall** is consistent.

Platform widths:
- flatLong: 120px
- flatMedium: 70px
- flatSmall: 40px

I'll align the left edge (for left column) and right edge (for right column) to a consistent position.

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // flatLong(120w)->center@540, flatMedium(70w)->center@565, flatSmall(40w)->center@580
            { shape: 'flatLong', x: 540, y: 765 },    // Tier 1
            { shape: 'flatLong', x: 540, y: 680 },    // Tier 2
            { shape: 'flatMedium', x: 565, y: 595 },  // Tier 3
            { shape: 'flatLong', x: 540, y: 530 },    // Tier 4
            { shape: 'flatLong', x: 540, y: 450 },    // Tier 5
            { shape: 'flatMedium', x: 565, y: 375 },  // Tier 6
            { shape: 'flatLong', x: 540, y: 285 },    // Tier 7
            { shape: 'flatSmall', x: 580, y: 200 },   // Tier 8 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Now:
- **Left column:** All platforms have their LEFT edge at x=100 (~45px gap from wall at x=55)
- **Right column:** All platforms have their RIGHT edge at x=600 (~45px gap from wall at x=645)

The gap is now consistent regardless of platform width. Press R to check!

---

**User**

perfect! see how there are 3 that are thicker vertically but have a kind of tunnel or hole in them? can we make some platforms like and inspired by that?

---

**Cursor**

Let me look at the reference image to see the tunnel/hole shapes you're describing.

I see them! On the right side - there are tall thick blocks with rectangular cutouts/tunnels through them. Like doorways or passages you could walk through.

Let me add some new shapes inspired by those and put them in Layout 1.

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === TUNNEL/ARCH BLOCKS (inspired by reference - tall blocks with holes) ===
    
    // Tall block with horizontal tunnel through middle (like a doorway)
    tunnelBlockTall: {
        points: [
            {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 25},      // top
            {x: 45, y: 25}, {x: 45, y: 55}, {x: 60, y: 55},   // right side of tunnel
            {x: 60, y: 80}, {x: 0, y: 80},                     // bottom
            {x: 0, y: 55}, {x: 15, y: 55}, {x: 15, y: 25}, {x: 0, y: 25}  // left side of tunnel
        ],
        width: 60,
        height: 80
    },
    
    // Wider tunnel block (shorter but wider passage)
    tunnelBlockWide: {
        points: [
            {x: 0, y: 0}, {x: 80, y: 0}, {x: 80, y: 20},      // top
            {x: 60, y: 20}, {x: 60, y: 45}, {x: 80, y: 45},   // right side of tunnel
            {x: 80, y: 65}, {x: 0, y: 65},                     // bottom
            {x: 0, y: 45}, {x: 20, y: 45}, {x: 20, y: 20}, {x: 0, y: 20}  // left side of tunnel
        ],
        width: 80,
        height: 65
    },
    
    // Arch block (tunnel at the bottom, like walking under)
    archBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 50},      // top and right side
            {x: 35, y: 50}, {x: 35, y: 30}, {x: 15, y: 30}, {x: 15, y: 50},  // arch cutout
            {x: 0, y: 50}                                      // left side
        ],
        width: 50,
        height: 50
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // flatLong(120w)->center@540, flatMedium(70w)->center@565, flatSmall(40w)->center@580
            { shape: 'flatLong', x: 540, y: 765 },    // Tier 1
            { shape: 'flatLong', x: 540, y: 680 },    // Tier 2
            { shape: 'flatMedium', x: 565, y: 595 },  // Tier 3
            { shape: 'flatLong', x: 540, y: 530 },    // Tier 4
            { shape: 'flatLong', x: 540, y: 450 },    // Tier 5
            { shape: 'flatMedium', x: 565, y: 375 },  // Tier 6
            { shape: 'flatLong', x: 540, y: 285 },    // Tier 7
            { shape: 'flatSmall', x: 580, y: 200 },   // Tier 8 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Now let me add a couple of these to Layout 1 on the right side (like the reference):

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === TUNNEL/ARCH BLOCKS (inspired by reference - tall blocks with holes) ===
    
    // Tall block with horizontal tunnel through middle (like a doorway)
    tunnelBlockTall: {
        points: [
            {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 25},      // top
            {x: 45, y: 25}, {x: 45, y: 55}, {x: 60, y: 55},   // right side of tunnel
            {x: 60, y: 80}, {x: 0, y: 80},                     // bottom
            {x: 0, y: 55}, {x: 15, y: 55}, {x: 15, y: 25}, {x: 0, y: 25}  // left side of tunnel
        ],
        width: 60,
        height: 80
    },
    
    // Wider tunnel block (shorter but wider passage)
    tunnelBlockWide: {
        points: [
            {x: 0, y: 0}, {x: 80, y: 0}, {x: 80, y: 20},      // top
            {x: 60, y: 20}, {x: 60, y: 45}, {x: 80, y: 45},   // right side of tunnel
            {x: 80, y: 65}, {x: 0, y: 65},                     // bottom
            {x: 0, y: 45}, {x: 20, y: 45}, {x: 20, y: 20}, {x: 0, y: 20}  // left side of tunnel
        ],
        width: 80,
        height: 65
    },
    
    // Arch block (tunnel at the bottom, like walking under)
    archBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 50},      // top and right side
            {x: 35, y: 50}, {x: 35, y: 30}, {x: 15, y: 30}, {x: 15, y: 50},  // arch cutout
            {x: 0, y: 50}                                      // left side
        ],
        width: 50,
        height: 50
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // flatLong(120w)->center@540, flatMedium(70w)->center@565, flatSmall(40w)->center@580
            // tunnelBlockTall(60w)->center@570, tunnelBlockWide(80w)->center@560
            { shape: 'flatLong', x: 540, y: 765 },       // Tier 1
            { shape: 'tunnelBlockTall', x: 570, y: 680 }, // Tier 2 - tunnel block!
            { shape: 'flatMedium', x: 565, y: 570 },     // Tier 3
            { shape: 'tunnelBlockWide', x: 560, y: 490 }, // Tier 4 - tunnel block!
            { shape: 'flatLong', x: 540, y: 400 },       // Tier 5
            { shape: 'tunnelBlockTall', x: 570, y: 310 }, // Tier 6 - tunnel block!
            { shape: 'flatSmall', x: 580, y: 200 },      // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Added 3 new shapes:
- **`tunnelBlockTall`** (60x80) - tall block with horizontal tunnel through middle
- **`tunnelBlockWide`** (80x65) - wider block with wider passage
- **`archBlock`** (50x50) - block with arch at bottom

Put 3 tunnel blocks in Layout 1's right column. Press R to check them out!

---

**User**

the idea is kind of right but not the execution. you see how the one on the left side of the reference has like a zig zag shaped gap? i want a platform that spawns or generates as one but is basically two pieces and has a gap like that. the one on the right of my reference image is the same idea. one platform spawn but a gap in the middle of it to drop down vertically. and then the other one on the right of the reference similarly has like a horizontally bored tunnel in it to walk into.

---

**Cursor**

Ah, I see what you mean now! The issue is that my current shapes are just outlines - the collision is still a rectangle that fills the whole thing, so there's no actual gap to drop/walk through.

What you want:
1. **Zig-zag gap** (like left reference) - looks like one platform but has a diagonal/step gap to drop through
2. **Vertical slot** - tall block with a slot you can fall down through
3. **Horizontal tunnel** - block with a passage you can walk into

The problem: Phaser's collision is rectangular per sprite. To have actual passable gaps, I need to place **multiple collision bodies** that together *look* like one shape but leave gaps between them.

Two options:

**Option A:** Create "compound" platform types that place 2-3 collision rectangles arranged to form the shape with real gaps. More work but cleaner.

**Option B:** Manually place separate simpler shapes (like two L-shapes) positioned to look like one platform with a gap. Quick but messier.

Which approach would you prefer? Option A would be better for the generator long-term.

---

**User**

definitely A

---

**Cursor**

```javascript
zigZagGap: {
    points: [...], // visual outline including the gap
    width: 70,
    height: 70,
    parts: [
        { x: 0, y: 0, w: 35, h: 35 },   // top-left block
        { x: 35, y: 35, w: 35, h: 35 }  // bottom-right block
    ]
}
```

Let me implement compound platforms. I'll:
1. Add a `parts` array to shape definitions that specifies the collision rectangles
2. Modify `loadLayout` to create multiple collision bodies for these shapes

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array defining separate collision rectangles
    // The visual is drawn as one shape, but collision uses multiple bodies
    
    // Zig-zag gap - two blocks arranged diagonally with drop-through gap
    // Looks like: â–â–€  (top-left block over bottom-right block with diagonal gap)
    //              â–€â–Œ
    zigZagGap: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 30},      // top-left block
            {x: 70, y: 30}, {x: 70, y: 35},                    // step right
            {x: 50, y: 35}, {x: 50, y: 65},                    // gap
            {x: 90, y: 65}, {x: 90, y: 95}, {x: 40, y: 95},   // bottom-right block
            {x: 40, y: 65}, {x: 20, y: 65}, {x: 20, y: 30},   // gap other side
            {x: 0, y: 30}
        ],
        width: 90,
        height: 95,
        parts: [
            { x: 0, y: 0, w: 50, h: 30 },     // top-left block
            { x: 40, y: 65, w: 50, h: 30 }    // bottom-right block
        ]
    },
    
    // Vertical slot - tall block with vertical gap to drop through
    verticalSlot: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 70}, {x: 0, y: 70},  // left pillar
            {x: 0, y: 0},  // back to start for left
            {x: 45, y: 0}, {x: 70, y: 0}, {x: 70, y: 70}, {x: 45, y: 70}, {x: 45, y: 0}  // right pillar
        ],
        width: 70,
        height: 70,
        parts: [
            { x: 0, y: 0, w: 25, h: 70 },     // left pillar
            { x: 45, y: 0, w: 25, h: 70 }     // right pillar
        ]
    },
    
    // Horizontal tunnel - block with walk-through passage
    horizontalTunnel: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 20},      // top bar
            {x: 70, y: 20}, {x: 70, y: 45}, {x: 70, y: 65},   // right side
            {x: 0, y: 65}, {x: 0, y: 45},                      // bottom bar
            {x: 0, y: 20}                                       // left side
        ],
        width: 70,
        height: 65,
        parts: [
            { x: 0, y: 0, w: 70, h: 20 },     // top bar
            { x: 0, y: 45, w: 70, h: 20 }     // bottom bar
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // flatLong(120w)->center@540, flatMedium(70w)->center@565, flatSmall(40w)->center@580
            // tunnelBlockTall(60w)->center@570, tunnelBlockWide(80w)->center@560
            { shape: 'flatLong', x: 540, y: 765 },       // Tier 1
            { shape: 'tunnelBlockTall', x: 570, y: 680 }, // Tier 2 - tunnel block!
            { shape: 'flatMedium', x: 565, y: 570 },     // Tier 3
            { shape: 'tunnelBlockWide', x: 560, y: 490 }, // Tier 4 - tunnel block!
            { shape: 'flatLong', x: 540, y: 400 },       // Tier 5
            { shape: 'tunnelBlockTall', x: 570, y: 310 }, // Tier 6 - tunnel block!
            { shape: 'flatSmall', x: 580, y: 200 },      // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Now let me modify `loadLayout` to handle compound shapes:

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart | G: new map', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Now let me update Layout 1 to use the new compound shapes:

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array defining separate collision rectangles
    // The visual is drawn as one shape, but collision uses multiple bodies
    
    // Zig-zag gap - two blocks arranged diagonally with drop-through gap
    // Looks like: â–â–€  (top-left block over bottom-right block with diagonal gap)
    //              â–€â–Œ
    zigZagGap: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 30},      // top-left block
            {x: 70, y: 30}, {x: 70, y: 35},                    // step right
            {x: 50, y: 35}, {x: 50, y: 65},                    // gap
            {x: 90, y: 65}, {x: 90, y: 95}, {x: 40, y: 95},   // bottom-right block
            {x: 40, y: 65}, {x: 20, y: 65}, {x: 20, y: 30},   // gap other side
            {x: 0, y: 30}
        ],
        width: 90,
        height: 95,
        parts: [
            { x: 0, y: 0, w: 50, h: 30 },     // top-left block
            { x: 40, y: 65, w: 50, h: 30 }    // bottom-right block
        ]
    },
    
    // Vertical slot - tall block with vertical gap to drop through
    verticalSlot: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 70}, {x: 0, y: 70},  // left pillar
            {x: 0, y: 0},  // back to start for left
            {x: 45, y: 0}, {x: 70, y: 0}, {x: 70, y: 70}, {x: 45, y: 70}, {x: 45, y: 0}  // right pillar
        ],
        width: 70,
        height: 70,
        parts: [
            { x: 0, y: 0, w: 25, h: 70 },     // left pillar
            { x: 45, y: 0, w: 25, h: 70 }     // right pillar
        ]
    },
    
    // Horizontal tunnel - block with walk-through passage
    horizontalTunnel: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 20},      // top bar
            {x: 70, y: 20}, {x: 70, y: 45}, {x: 70, y: 65},   // right side
            {x: 0, y: 65}, {x: 0, y: 45},                      // bottom bar
            {x: 0, y: 20}                                       // left side
        ],
        width: 70,
        height: 65,
        parts: [
            { x: 0, y: 0, w: 70, h: 20 },     // top bar
            { x: 0, y: 45, w: 70, h: 20 }     // bottom bar
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Created 3 compound shapes with real passable gaps:

- **`zigZagGap`** - Two blocks arranged diagonally, drop through the gap
- **`verticalSlot`** - Two pillars with a slot to fall through
- **`horizontalTunnel`** - Top and bottom bars with walk-through passage

The system now:
1. Draws the shape as one visual
2. Creates separate collision rectangles for each solid part
3. Leaves the gaps actually passable

Press R to test! Try dropping/walking through the compound shapes on the right side.

---

**User**

can you give me the ability to toggle fly with the F key or something so i can get over to those?

---

**Cursor**

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart | G: new map', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart | G: new map', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(-speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Jumping - only allow when touching the ground
        // blocked.down means something is directly below the player
        if (this.cursors.up.isDown && this.player.body.blocked.down) {
            this.player.setVelocityY(jumpVelocity);
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Up: jump | Click: shoot | R: restart | G: new map', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape from points
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            const points = shapeData.points;
            
            // Draw sketchy outline following the shape points
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            g.beginPath();
            
            // Move to first point with wobble
            g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            
            // Draw lines to each subsequent point with wobble
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
            }
            
            // Close the shape
            g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
            g.strokePath();
            
            // Very light fill
            g.fillStyle(0x000000, 0.05);
            g.beginPath();
            g.moveTo(points[0].x + 3, points[0].y + 3);
            for (let i = 1; i < points.length; i++) {
                g.lineTo(points[i].x + 3, points[i].y + 3);
            }
            g.closePath();
            g.fillPath();
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R: restart | G: new map | F: fly', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Done! Press **F** to toggle fly mode:
- **Fly mode ON:** No gravity, arrow keys move in all directions
- **Fly mode OFF:** Normal physics

Refresh and fly over to test those compound platforms!

---

**User**

i can fly through some of the compound shapes and there is collision within them but the drawn borders for them do not at all match the collision rectangles it seems. perhaps there should be more than just 2 or 3 collision rectangles for them, like an L shaped piece can be accomplished with 2 rectangles. but more complex shapes maybe more.

---

**Cursor**

```plaintext
â–ˆ â–ˆ â–ˆ 
â–ˆ
â–ˆ
```

You're right - my collision rectangles don't match the drawn shapes. Let me redesign these with proper geometry where the collision parts actually match the visual.

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array defining separate collision rectangles
    // The visual is drawn as one shape, collision uses multiple bodies that MATCH the visual
    
    // Zig-zag gap - L-shape on top of inverted-L, diagonal gap to drop through
    // Visual:  â–ˆâ–ˆâ–ˆâ–ˆ
    //          â–ˆ
    //          â–ˆ
    //             â–ˆ
    //             â–ˆ
    //          â–ˆâ–ˆâ–ˆâ–ˆ
    zigZagGap: {
        points: [
            // Top L-shape (horizontal bar + vertical stem)
            {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 15},      // top bar
            {x: 15, y: 15}, {x: 15, y: 45},                    // stem going down
            {x: 0, y: 45}, {x: 0, y: 0},                       // close top L
            // Bottom inverted-L (move to it)
            {x: 45, y: 35}, {x: 60, y: 35}, {x: 60, y: 65},   // stem going down
            {x: 60, y: 80}, {x: 0, y: 80}, {x: 0, y: 65},     // bottom bar
            {x: 45, y: 65}, {x: 45, y: 35}                     // close bottom L
        ],
        width: 60,
        height: 80,
        parts: [
            // Top L-shape (2 rectangles)
            { x: 0, y: 0, w: 60, h: 15 },      // top horizontal bar
            { x: 0, y: 15, w: 15, h: 30 },     // left vertical stem
            // Bottom inverted-L (2 rectangles)
            { x: 45, y: 35, w: 15, h: 30 },    // right vertical stem
            { x: 0, y: 65, w: 60, h: 15 }      // bottom horizontal bar
        ]
    },
    
    // Vertical slot - wide block with vertical slot to drop through middle
    // Visual:  â–ˆâ–ˆ  â–ˆâ–ˆ
    //          â–ˆâ–ˆ  â–ˆâ–ˆ
    //          â–ˆâ–ˆ  â–ˆâ–ˆ
    verticalSlot: {
        points: [
            // Left pillar
            {x: 0, y: 0}, {x: 20, y: 0}, {x: 20, y: 60}, {x: 0, y: 60}, {x: 0, y: 0},
            // Right pillar (separate outline)
            {x: 40, y: 0}, {x: 60, y: 0}, {x: 60, y: 60}, {x: 40, y: 60}, {x: 40, y: 0}
        ],
        width: 60,
        height: 60,
        parts: [
            { x: 0, y: 0, w: 20, h: 60 },     // left pillar
            { x: 40, y: 0, w: 20, h: 60 }     // right pillar
        ]
    },
    
    // Horizontal tunnel - block with walk-through passage in middle
    // Visual:  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    //          â–ˆ    â–ˆ
    //          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    horizontalTunnel: {
        points: [
            // Outer rectangle
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 50}, {x: 0, y: 50}, {x: 0, y: 0},
            // Inner cutout (tunnel)
            {x: 10, y: 15}, {x: 60, y: 15}, {x: 60, y: 35}, {x: 10, y: 35}, {x: 10, y: 15}
        ],
        width: 70,
        height: 50,
        parts: [
            { x: 0, y: 0, w: 70, h: 15 },     // top bar
            { x: 0, y: 15, w: 10, h: 20 },    // left wall of tunnel
            { x: 60, y: 15, w: 10, h: 20 },   // right wall of tunnel
            { x: 0, y: 35, w: 70, h: 15 }     // bottom bar
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Redesigned the compound shapes with collision parts that match the visuals:

**zigZagGap** - Now 4 parts:
- Top horizontal bar
- Left vertical stem (top L)
- Right vertical stem (bottom inverted L)  
- Bottom horizontal bar

**verticalSlot** - 2 parts (left & right pillars)

**horizontalTunnel** - Now 4 parts:
- Top bar
- Left tunnel wall
- Right tunnel wall
- Bottom bar

Press R and fly over to test. The collision should now match what's drawn much better!

---

**User**

we're getting close to collision boxes that make sense but the drawings still dont match them. lets do these one by one. we need maybe 4 or 5 compound shapes before we can make some rules

---

**Cursor**

Good plan. Let's do them one at a time. I'll focus on making the visual `points` draw exactly what the collision `parts` represent.

**Let's start with shape #1: verticalSlot** (simplest - just two pillars with a gap)

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array defining separate collision rectangles
    // The visual is drawn as one shape, collision uses multiple bodies that MATCH the visual
    
    // Zig-zag gap - L-shape on top of inverted-L, diagonal gap to drop through
    // Visual:  â–ˆâ–ˆâ–ˆâ–ˆ
    //          â–ˆ
    //          â–ˆ
    //             â–ˆ
    //             â–ˆ
    //          â–ˆâ–ˆâ–ˆâ–ˆ
    zigZagGap: {
        points: [
            // Top L-shape (horizontal bar + vertical stem)
            {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 15},      // top bar
            {x: 15, y: 15}, {x: 15, y: 45},                    // stem going down
            {x: 0, y: 45}, {x: 0, y: 0},                       // close top L
            // Bottom inverted-L (move to it)
            {x: 45, y: 35}, {x: 60, y: 35}, {x: 60, y: 65},   // stem going down
            {x: 60, y: 80}, {x: 0, y: 80}, {x: 0, y: 65},     // bottom bar
            {x: 45, y: 65}, {x: 45, y: 35}                     // close bottom L
        ],
        width: 60,
        height: 80,
        parts: [
            // Top L-shape (2 rectangles)
            { x: 0, y: 0, w: 60, h: 15 },      // top horizontal bar
            { x: 0, y: 15, w: 15, h: 30 },     // left vertical stem
            // Bottom inverted-L (2 rectangles)
            { x: 45, y: 35, w: 15, h: 30 },    // right vertical stem
            { x: 0, y: 65, w: 60, h: 15 }      // bottom horizontal bar
        ]
    },
    
    // Vertical slot - two pillars with drop-through gap in middle
    // Visual:  â–ˆâ–ˆ    â–ˆâ–ˆ
    //          â–ˆâ–ˆ    â–ˆâ–ˆ
    //          â–ˆâ–ˆ    â–ˆâ–ˆ
    // Collision: left pillar (20x60) + right pillar (20x60), gap of 20px between
    verticalSlot: {
        points: [
            // Draw as one connected shape: down left side, across bottom, up middle-left,
            // across gap at top, down middle-right, across bottom, up right side, across top
            {x: 0, y: 0},    // top-left corner
            {x: 20, y: 0},   // top of left pillar right edge
            {x: 20, y: 60},  // bottom of left pillar right edge
            {x: 0, y: 60},   // bottom-left corner
            {x: 0, y: 0},    // back to start (close left pillar)
            // Jump to right pillar
            {x: 40, y: 0},   // top of right pillar left edge
            {x: 60, y: 0},   // top-right corner
            {x: 60, y: 60},  // bottom-right corner
            {x: 40, y: 60},  // bottom of right pillar left edge
            {x: 40, y: 0}    // close right pillar
        ],
        width: 60,
        height: 60,
        parts: [
            { x: 0, y: 0, w: 20, h: 60 },     // left pillar: 20 wide, 60 tall
            { x: 40, y: 0, w: 20, h: 60 }     // right pillar: 20 wide, 60 tall, starts at x=40
        ]
    },
    
    // Horizontal tunnel - block with walk-through passage in middle
    // Visual:  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    //          â–ˆ    â–ˆ
    //          â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    horizontalTunnel: {
        points: [
            // Outer rectangle
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 50}, {x: 0, y: 50}, {x: 0, y: 0},
            // Inner cutout (tunnel)
            {x: 10, y: 15}, {x: 60, y: 15}, {x: 60, y: 35}, {x: 10, y: 35}, {x: 10, y: 15}
        ],
        width: 70,
        height: 50,
        parts: [
            { x: 0, y: 0, w: 70, h: 15 },     // top bar
            { x: 0, y: 15, w: 10, h: 20 },    // left wall of tunnel
            { x: 60, y: 15, w: 10, h: 20 },   // right wall of tunnel
            { x: 0, y: 35, w: 70, h: 15 }     // bottom bar
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Actually wait - the drawing function connects all points as one polygon. For two separate pillars, I need to modify how compound shapes are drawn. Let me check the drawing code:

I see the issue - it draws one continuous line. For compound shapes, I need to draw each part separately. Let me modify the drawing function:

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: draw each part as a separate rectangle
                for (const part of shapeData.parts) {
                    // Draw rectangle outline with wobble
                    g.beginPath();
                    g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                    g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                    g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                    g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                    g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                    g.strokePath();
                    
                    // Light fill for this part
                    g.fillStyle(0x000000, 0.05);
                    g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
                
                // Very light fill
                g.fillStyle(0x000000, 0.05);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R: restart | G: new map | F: fly', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Now compound shapes draw directly from the `parts` array - each part is drawn as a rectangle. The visual should now exactly match the collision!

Let me simplify the compound shape definitions since we no longer need `points` for them:

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array - both visual AND collision are drawn from parts
    // Each part is a rectangle: { x, y, w, h } relative to shape origin
    
    // Shape #1: Vertical slot - two pillars with drop-through gap
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    verticalSlot: {
        width: 60,
        height: 60,
        parts: [
            { x: 0, y: 0, w: 20, h: 60 },     // left pillar
            { x: 40, y: 0, w: 20, h: 60 }     // right pillar (20px gap between)
        ]
    },
    
    // Shape #2: Horizontal tunnel - walk-through passage
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆ    â–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    horizontalTunnel: {
        width: 70,
        height: 50,
        parts: [
            { x: 0, y: 0, w: 70, h: 15 },     // top bar
            { x: 0, y: 15, w: 10, h: 20 },    // left wall
            { x: 60, y: 15, w: 10, h: 20 },   // right wall
            { x: 0, y: 35, w: 70, h: 15 }     // bottom bar
        ]
    },
    
    // Shape #3: Zig-zag gap - diagonal drop-through
    // â–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆ
    // â–ˆ
    //    â–ˆ
    //    â–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆ
    zigZagGap: {
        width: 60,
        height: 80,
        parts: [
            { x: 0, y: 0, w: 60, h: 15 },     // top bar
            { x: 0, y: 15, w: 15, h: 30 },    // left stem
            { x: 45, y: 35, w: 15, h: 30 },   // right stem
            { x: 0, y: 65, w: 60, h: 15 }     // bottom bar
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Now compound shapes are defined purely by `parts` - both visual AND collision come from the same data, so they'll match exactly.

Current compound shapes:
1. **verticalSlot** - Two pillars with 20px gap to drop through
2. **horizontalTunnel** - Walk-through passage in middle
3. **zigZagGap** - Diagonal passage between top-left and bottom-right

Press R to test these. Let me know how they look and if they work, then we'll add 1-2 more compound shapes!

---

**User**

ok. we're getting there. the vertical columns and zig zag function properly. the drawing thing you metnioned was definitely an issue that is now fixed. the zig zag could do without the "4 rectangles" appearance

---

**Cursor**

Good feedback! The zigZagGap should look like one connected shape, not 4 separate boxes. Let me add support for compound shapes to have a custom visual outline while keeping separate collision parts.

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.points) {
                    // Has custom outline - draw that for visual (looks connected)
                    const points = shapeData.points;
                    g.beginPath();
                    g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                    for (let i = 1; i < points.length; i++) {
                        g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                    }
                    g.closePath();
                    g.strokePath();
                    
                    // Light fill
                    g.fillStyle(0x000000, 0.05);
                    g.beginPath();
                    g.moveTo(points[0].x + 3, points[0].y + 3);
                    for (let i = 1; i < points.length; i++) {
                        g.lineTo(points[i].x + 3, points[i].y + 3);
                    }
                    g.closePath();
                    g.fillPath();
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                        
                        g.fillStyle(0x000000, 0.05);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
                
                // Very light fill
                g.fillStyle(0x000000, 0.05);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R: restart | G: new map | F: fly', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```plaintext
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (0,0 to 60,15)
â–ˆâ–ˆâ–ˆ           (0,15 to 15,45)

        â–ˆâ–ˆâ–ˆ   (45,35 to 60,65)
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (0,65 to 60,80)
```

Now let me add a custom outline to zigZagGap that makes it look connected. I'll add support for multiple outline groups:

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.outlines) {
                    // Has multiple outline groups - draw each as connected shape
                    for (const outline of shapeData.outlines) {
                        g.beginPath();
                        g.moveTo(outline[0].x + wobble() + 3, outline[0].y + wobble() + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + wobble() + 3, outline[i].y + wobble() + 3);
                        }
                        g.closePath();
                        g.strokePath();
                        
                        // Light fill
                        g.fillStyle(0x000000, 0.05);
                        g.beginPath();
                        g.moveTo(outline[0].x + 3, outline[0].y + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + 3, outline[i].y + 3);
                        }
                        g.closePath();
                        g.fillPath();
                    }
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                        
                        g.fillStyle(0x000000, 0.05);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
                
                // Very light fill
                g.fillStyle(0x000000, 0.05);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R: restart | G: new map | F: fly', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Now let me update zigZagGap with proper outlines for the two L-shapes:

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array - both visual AND collision are drawn from parts
    // Each part is a rectangle: { x, y, w, h } relative to shape origin
    
    // Shape #1: Vertical slot - two pillars with drop-through gap
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    verticalSlot: {
        width: 60,
        height: 60,
        parts: [
            { x: 0, y: 0, w: 20, h: 60 },     // left pillar
            { x: 40, y: 0, w: 20, h: 60 }     // right pillar (20px gap between)
        ]
    },
    
    // Shape #2: Horizontal tunnel - walk-through passage
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆ    â–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    horizontalTunnel: {
        width: 70,
        height: 50,
        parts: [
            { x: 0, y: 0, w: 70, h: 15 },     // top bar
            { x: 0, y: 15, w: 10, h: 20 },    // left wall
            { x: 60, y: 15, w: 10, h: 20 },   // right wall
            { x: 0, y: 35, w: 70, h: 15 }     // bottom bar
        ]
    },
    
    // Shape #3: Zig-zag gap - diagonal drop-through (two L-shapes)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆâ–ˆ
    // â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    zigZagGap: {
        width: 60,
        height: 80,
        parts: [
            { x: 0, y: 0, w: 60, h: 15 },     // top bar
            { x: 0, y: 15, w: 15, h: 30 },    // left stem
            { x: 45, y: 35, w: 15, h: 30 },   // right stem
            { x: 0, y: 65, w: 60, h: 15 }     // bottom bar
        ],
        // Custom outlines: two L-shapes drawn separately
        outlines: [
            // Top L-shape (top bar + left stem)
            [
                {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 15}, {x: 15, y: 15},
                {x: 15, y: 45}, {x: 0, y: 45}
            ],
            // Bottom inverted-L (right stem + bottom bar)
            [
                {x: 45, y: 35}, {x: 60, y: 35}, {x: 60, y: 80}, {x: 0, y: 80},
                {x: 0, y: 65}, {x: 45, y: 65}
            ]
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Now zigZagGap draws as two L-shaped outlines (top-L and bottom-inverted-L) instead of 4 separate boxes. The collision is still the 4 rectangles, but the visual looks like two connected pieces.

Press R to test - it should look more like the reference now!

---

**User**

good! now can we add a toggle to hide and display the collision hitboxes for debugging? maybe H key

---

**Cursor**

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.outlines) {
                    // Has multiple outline groups - draw each as connected shape
                    for (const outline of shapeData.outlines) {
                        g.beginPath();
                        g.moveTo(outline[0].x + wobble() + 3, outline[0].y + wobble() + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + wobble() + 3, outline[i].y + wobble() + 3);
                        }
                        g.closePath();
                        g.strokePath();
                        
                        // Light fill
                        g.fillStyle(0x000000, 0.05);
                        g.beginPath();
                        g.moveTo(outline[0].x + 3, outline[0].y + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + 3, outline[i].y + 3);
                        }
                        g.closePath();
                        g.fillPath();
                    }
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                        
                        g.fillStyle(0x000000, 0.05);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
                
                // Very light fill
                g.fillStyle(0x000000, 0.05);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R: restart | G: new map | F: fly', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        // H key to toggle hitbox display
        this.hitboxKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.H);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.outlines) {
                    // Has multiple outline groups - draw each as connected shape
                    for (const outline of shapeData.outlines) {
                        g.beginPath();
                        g.moveTo(outline[0].x + wobble() + 3, outline[0].y + wobble() + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + wobble() + 3, outline[i].y + wobble() + 3);
                        }
                        g.closePath();
                        g.strokePath();
                        
                        // Light fill
                        g.fillStyle(0x000000, 0.05);
                        g.beginPath();
                        g.moveTo(outline[0].x + 3, outline[0].y + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + 3, outline[i].y + 3);
                        }
                        g.closePath();
                        g.fillPath();
                    }
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                        
                        g.fillStyle(0x000000, 0.05);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
                
                // Very light fill
                g.fillStyle(0x000000, 0.05);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R: restart | G: new map | F: fly', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        // H key to toggle hitbox display
        this.hitboxKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.H);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        // Toggle hitbox debug display
        if (Phaser.Input.Keyboard.JustDown(this.hitboxKey)) {
            this.physics.world.debugGraphic.visible = !this.physics.world.debugGraphic.visible;
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.outlines) {
                    // Has multiple outline groups - draw each as connected shape
                    for (const outline of shapeData.outlines) {
                        g.beginPath();
                        g.moveTo(outline[0].x + wobble() + 3, outline[0].y + wobble() + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + wobble() + 3, outline[i].y + wobble() + 3);
                        }
                        g.closePath();
                        g.strokePath();
                        
                        // Light fill
                        g.fillStyle(0x000000, 0.05);
                        g.beginPath();
                        g.moveTo(outline[0].x + 3, outline[0].y + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + 3, outline[i].y + 3);
                        }
                        g.closePath();
                        g.fillPath();
                    }
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                        
                        g.fillStyle(0x000000, 0.05);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
                
                // Very light fill
                g.fillStyle(0x000000, 0.05);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R: restart | G: new map | F: fly', {
            fontSize: '10px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        // H key to toggle hitbox display
        this.hitboxKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.H);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        // Toggle hitbox debug display
        if (Phaser.Input.Keyboard.JustDown(this.hitboxKey)) {
            if (this.physics.world.debugGraphic) {
                this.physics.world.debugGraphic.visible = !this.physics.world.debugGraphic.visible;
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.outlines) {
                    // Has multiple outline groups - draw each as connected shape
                    for (const outline of shapeData.outlines) {
                        g.beginPath();
                        g.moveTo(outline[0].x + wobble() + 3, outline[0].y + wobble() + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + wobble() + 3, outline[i].y + wobble() + 3);
                        }
                        g.closePath();
                        g.strokePath();
                        
                        // Light fill
                        g.fillStyle(0x000000, 0.05);
                        g.beginPath();
                        g.moveTo(outline[0].x + 3, outline[0].y + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + 3, outline[i].y + 3);
                        }
                        g.closePath();
                        g.fillPath();
                    }
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                        
                        g.fillStyle(0x000000, 0.05);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
                
                // Very light fill
                g.fillStyle(0x000000, 0.05);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R/G: restart/new | F: fly | H: hitbox', {
            fontSize: '9px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        // H key to toggle hitbox display
        this.hitboxKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.H);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        // Toggle hitbox debug display
        if (Phaser.Input.Keyboard.JustDown(this.hitboxKey)) {
            if (this.physics.world.debugGraphic) {
                this.physics.world.debugGraphic.visible = !this.physics.world.debugGraphic.visible;
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Done! Press **H** to toggle the green hitbox debug display on/off. Refresh and try it out - should make it easy to see where the collision boxes are vs the visual drawings.

---

**User**

this is looking great so far. can we fill the walls and platforms with a super light transparent gray? ideally with like a kind of crayon like appearance

---

**Cursor**

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.outlines) {
                    // Has multiple outline groups - draw each as connected shape
                    for (const outline of shapeData.outlines) {
                        // Crayon-like fill with diagonal hatching
                        g.fillStyle(0x888888, 0.12);
                        g.beginPath();
                        g.moveTo(outline[0].x + 3, outline[0].y + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + 3, outline[i].y + 3);
                        }
                        g.closePath();
                        g.fillPath();
                        
                        // Outline
                        g.beginPath();
                        g.moveTo(outline[0].x + wobble() + 3, outline[0].y + wobble() + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + wobble() + 3, outline[i].y + wobble() + 3);
                        }
                        g.closePath();
                        g.strokePath();
                    }
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        // Crayon-like fill
                        g.fillStyle(0x888888, 0.12);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                        
                        // Outline
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
                
                // Very light fill
                g.fillStyle(0x000000, 0.05);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R/G: restart/new | F: fly | H: hitbox', {
            fontSize: '9px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        // H key to toggle hitbox display
        this.hitboxKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.H);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        // Toggle hitbox debug display
        if (Phaser.Input.Keyboard.JustDown(this.hitboxKey)) {
            if (this.physics.world.debugGraphic) {
                this.physics.world.debugGraphic.visible = !this.physics.world.debugGraphic.visible;
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style) ===
        const wallGraphics = this.add.graphics();
        wallGraphics.lineStyle(2.5, 0x1a1a1a);  // Black pen
        
        // Left wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(55, 795);
        // Horizontal line to left edge
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - irregular vertical line with horizontal bottom
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            wallGraphics.lineTo(wobbleX, y);
        }
        wallGraphics.lineTo(645, 795);
        // Horizontal line to right edge
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.outlines) {
                    // Has multiple outline groups - draw each as connected shape
                    for (const outline of shapeData.outlines) {
                        // Crayon-like fill with diagonal hatching
                        g.fillStyle(0x888888, 0.12);
                        g.beginPath();
                        g.moveTo(outline[0].x + 3, outline[0].y + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + 3, outline[i].y + 3);
                        }
                        g.closePath();
                        g.fillPath();
                        
                        // Outline
                        g.beginPath();
                        g.moveTo(outline[0].x + wobble() + 3, outline[0].y + wobble() + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + wobble() + 3, outline[i].y + wobble() + 3);
                        }
                        g.closePath();
                        g.strokePath();
                    }
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        // Crayon-like fill
                        g.fillStyle(0x888888, 0.12);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                        
                        // Outline
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                // Crayon-like fill
                g.fillStyle(0x888888, 0.12);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
                
                // Add subtle diagonal crayon strokes
                g.lineStyle(0.5, 0x666666, 0.15);
                for (let y = 0; y < shapeData.height; y += 6) {
                    g.beginPath();
                    g.moveTo(3 + wobble(), y + 3 + wobble());
                    g.lineTo(Math.min(shapeData.width, y + 20) + 3 + wobble(), Math.min(shapeData.height, y + 20) + 3 + wobble());
                    g.strokePath();
                }
                g.lineStyle(2, 0x1a1a1a);  // Reset for outline
                
                // Outline
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R/G: restart/new | F: fly | H: hitbox', {
            fontSize: '9px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        // H key to toggle hitbox display
        this.hitboxKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.H);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        // Toggle hitbox debug display
        if (Phaser.Input.Keyboard.JustDown(this.hitboxKey)) {
            if (this.physics.world.debugGraphic) {
                this.physics.world.debugGraphic.visible = !this.physics.world.debugGraphic.visible;
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Now let me add fill to the walls too:

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style with crayon fill) ===
        const wallGraphics = this.add.graphics();
        
        // Left wall - fill first, then outline
        // Build path points for left wall
        const leftWallPoints = [{x: 55, y: 0}];
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            leftWallPoints.push({x: wobbleX, y: y});
        }
        leftWallPoints.push({x: 55, y: 795}, {x: 0, y: 795}, {x: 0, y: 0});
        
        // Fill left wall
        wallGraphics.fillStyle(0x888888, 0.12);
        wallGraphics.beginPath();
        wallGraphics.moveTo(leftWallPoints[0].x, leftWallPoints[0].y);
        for (let i = 1; i < leftWallPoints.length; i++) {
            wallGraphics.lineTo(leftWallPoints[i].x, leftWallPoints[i].y);
        }
        wallGraphics.closePath();
        wallGraphics.fillPath();
        
        // Crayon strokes for left wall
        wallGraphics.lineStyle(0.5, 0x666666, 0.15);
        for (let y = 0; y < 795; y += 8) {
            wallGraphics.beginPath();
            wallGraphics.moveTo((Math.random() - 0.5) * 2, y + (Math.random() - 0.5) * 2);
            wallGraphics.lineTo(50 + (Math.random() - 0.5) * 10, y + 15 + (Math.random() - 0.5) * 2);
            wallGraphics.strokePath();
        }
        
        // Outline left wall
        wallGraphics.lineStyle(2.5, 0x1a1a1a);
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let i = 1; i < leftWallPoints.length - 2; i++) {
            wallGraphics.lineTo(leftWallPoints[i].x, leftWallPoints[i].y);
        }
        wallGraphics.lineTo(55, 795);
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - fill first, then outline
        const rightWallPoints = [{x: 645, y: 0}];
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            rightWallPoints.push({x: wobbleX, y: y});
        }
        rightWallPoints.push({x: 645, y: 795}, {x: 700, y: 795}, {x: 700, y: 0});
        
        // Fill right wall
        wallGraphics.fillStyle(0x888888, 0.12);
        wallGraphics.beginPath();
        wallGraphics.moveTo(rightWallPoints[0].x, rightWallPoints[0].y);
        for (let i = 1; i < rightWallPoints.length; i++) {
            wallGraphics.lineTo(rightWallPoints[i].x, rightWallPoints[i].y);
        }
        wallGraphics.closePath();
        wallGraphics.fillPath();
        
        // Crayon strokes for right wall
        wallGraphics.lineStyle(0.5, 0x666666, 0.15);
        for (let y = 0; y < 795; y += 8) {
            wallGraphics.beginPath();
            wallGraphics.moveTo(650 + (Math.random() - 0.5) * 2, y + (Math.random() - 0.5) * 2);
            wallGraphics.lineTo(700 + (Math.random() - 0.5) * 2, y + 15 + (Math.random() - 0.5) * 2);
            wallGraphics.strokePath();
        }
        
        // Outline right wall
        wallGraphics.lineStyle(2.5, 0x1a1a1a);
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let i = 1; i < rightWallPoints.length - 2; i++) {
            wallGraphics.lineTo(rightWallPoints[i].x, rightWallPoints[i].y);
        }
        wallGraphics.lineTo(645, 795);
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.outlines) {
                    // Has multiple outline groups - draw each as connected shape
                    for (const outline of shapeData.outlines) {
                        // Crayon-like fill with diagonal hatching
                        g.fillStyle(0x888888, 0.12);
                        g.beginPath();
                        g.moveTo(outline[0].x + 3, outline[0].y + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + 3, outline[i].y + 3);
                        }
                        g.closePath();
                        g.fillPath();
                        
                        // Outline
                        g.beginPath();
                        g.moveTo(outline[0].x + wobble() + 3, outline[0].y + wobble() + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + wobble() + 3, outline[i].y + wobble() + 3);
                        }
                        g.closePath();
                        g.strokePath();
                    }
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        // Crayon-like fill
                        g.fillStyle(0x888888, 0.12);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                        
                        // Outline
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                // Crayon-like fill
                g.fillStyle(0x888888, 0.12);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
                
                // Add subtle diagonal crayon strokes
                g.lineStyle(0.5, 0x666666, 0.15);
                for (let y = 0; y < shapeData.height; y += 6) {
                    g.beginPath();
                    g.moveTo(3 + wobble(), y + 3 + wobble());
                    g.lineTo(Math.min(shapeData.width, y + 20) + 3 + wobble(), Math.min(shapeData.height, y + 20) + 3 + wobble());
                    g.strokePath();
                }
                g.lineStyle(2, 0x1a1a1a);  // Reset for outline
                
                // Outline
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R/G: restart/new | F: fly | H: hitbox', {
            fontSize: '9px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        // H key to toggle hitbox display
        this.hitboxKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.H);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        // Toggle hitbox debug display
        if (Phaser.Input.Keyboard.JustDown(this.hitboxKey)) {
            if (this.physics.world.debugGraphic) {
                this.physics.world.debugGraphic.visible = !this.physics.world.debugGraphic.visible;
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style with crayon fill) ===
        const wallGraphics = this.add.graphics();
        
        // Left wall - fill first, then outline
        // Build path points for left wall
        const leftWallPoints = [{x: 55, y: 0}];
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            leftWallPoints.push({x: wobbleX, y: y});
        }
        leftWallPoints.push({x: 55, y: 795}, {x: 0, y: 795}, {x: 0, y: 0});
        
        // Fill left wall
        wallGraphics.fillStyle(0x888888, 0.12);
        wallGraphics.beginPath();
        wallGraphics.moveTo(leftWallPoints[0].x, leftWallPoints[0].y);
        for (let i = 1; i < leftWallPoints.length; i++) {
            wallGraphics.lineTo(leftWallPoints[i].x, leftWallPoints[i].y);
        }
        wallGraphics.closePath();
        wallGraphics.fillPath();
        
        // Crayon strokes for left wall
        wallGraphics.lineStyle(0.5, 0x666666, 0.15);
        for (let y = 0; y < 795; y += 8) {
            wallGraphics.beginPath();
            wallGraphics.moveTo((Math.random() - 0.5) * 2, y + (Math.random() - 0.5) * 2);
            wallGraphics.lineTo(50 + (Math.random() - 0.5) * 10, y + 15 + (Math.random() - 0.5) * 2);
            wallGraphics.strokePath();
        }
        
        // Outline left wall
        wallGraphics.lineStyle(2.5, 0x1a1a1a);
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let i = 1; i < leftWallPoints.length - 2; i++) {
            wallGraphics.lineTo(leftWallPoints[i].x, leftWallPoints[i].y);
        }
        wallGraphics.lineTo(55, 795);
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - fill first, then outline
        const rightWallPoints = [{x: 645, y: 0}];
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            rightWallPoints.push({x: wobbleX, y: y});
        }
        rightWallPoints.push({x: 645, y: 795}, {x: 700, y: 795}, {x: 700, y: 0});
        
        // Fill right wall
        wallGraphics.fillStyle(0x888888, 0.12);
        wallGraphics.beginPath();
        wallGraphics.moveTo(rightWallPoints[0].x, rightWallPoints[0].y);
        for (let i = 1; i < rightWallPoints.length; i++) {
            wallGraphics.lineTo(rightWallPoints[i].x, rightWallPoints[i].y);
        }
        wallGraphics.closePath();
        wallGraphics.fillPath();
        
        // Crayon strokes for right wall
        wallGraphics.lineStyle(0.5, 0x666666, 0.15);
        for (let y = 0; y < 795; y += 8) {
            wallGraphics.beginPath();
            wallGraphics.moveTo(650 + (Math.random() - 0.5) * 2, y + (Math.random() - 0.5) * 2);
            wallGraphics.lineTo(700 + (Math.random() - 0.5) * 2, y + 15 + (Math.random() - 0.5) * 2);
            wallGraphics.strokePath();
        }
        
        // Outline right wall
        wallGraphics.lineStyle(2.5, 0x1a1a1a);
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let i = 1; i < rightWallPoints.length - 2; i++) {
            wallGraphics.lineTo(rightWallPoints[i].x, rightWallPoints[i].y);
        }
        wallGraphics.lineTo(645, 795);
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.outlines) {
                    // Has multiple outline groups - draw each as connected shape
                    for (const outline of shapeData.outlines) {
                        // Crayon-like fill
                        g.fillStyle(0x888888, 0.12);
                        g.beginPath();
                        g.moveTo(outline[0].x + 3, outline[0].y + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + 3, outline[i].y + 3);
                        }
                        g.closePath();
                        g.fillPath();
                    }
                    
                    // Add crayon strokes across the whole shape
                    g.lineStyle(0.5, 0x666666, 0.15);
                    for (let y = 0; y < shapeData.height; y += 6) {
                        g.beginPath();
                        g.moveTo(3 + wobble(), y + 3 + wobble());
                        g.lineTo(Math.min(shapeData.width, y + 20) + 3 + wobble(), Math.min(shapeData.height, y + 20) + 3 + wobble());
                        g.strokePath();
                    }
                    g.lineStyle(2, 0x1a1a1a);
                    
                    // Draw outlines
                    for (const outline of shapeData.outlines) {
                        g.beginPath();
                        g.moveTo(outline[0].x + wobble() + 3, outline[0].y + wobble() + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + wobble() + 3, outline[i].y + wobble() + 3);
                        }
                        g.closePath();
                        g.strokePath();
                    }
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        // Crayon-like fill
                        g.fillStyle(0x888888, 0.12);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                    }
                    
                    // Add crayon strokes
                    g.lineStyle(0.5, 0x666666, 0.15);
                    for (let y = 0; y < shapeData.height; y += 6) {
                        g.beginPath();
                        g.moveTo(3 + wobble(), y + 3 + wobble());
                        g.lineTo(Math.min(shapeData.width, y + 20) + 3 + wobble(), Math.min(shapeData.height, y + 20) + 3 + wobble());
                        g.strokePath();
                    }
                    g.lineStyle(2, 0x1a1a1a);
                    
                    // Draw outlines
                    for (const part of shapeData.parts) {
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                // Crayon-like fill
                g.fillStyle(0x888888, 0.12);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
                
                // Add subtle diagonal crayon strokes
                g.lineStyle(0.5, 0x666666, 0.15);
                for (let y = 0; y < shapeData.height; y += 6) {
                    g.beginPath();
                    g.moveTo(3 + wobble(), y + 3 + wobble());
                    g.lineTo(Math.min(shapeData.width, y + 20) + 3 + wobble(), Math.min(shapeData.height, y + 20) + 3 + wobble());
                    g.strokePath();
                }
                g.lineStyle(2, 0x1a1a1a);  // Reset for outline
                
                // Outline
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R/G: restart/new | F: fly | H: hitbox', {
            fontSize: '9px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        // H key to toggle hitbox display
        this.hitboxKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.H);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        // Toggle hitbox debug display
        if (Phaser.Input.Keyboard.JustDown(this.hitboxKey)) {
            if (this.physics.world.debugGraphic) {
                this.physics.world.debugGraphic.visible = !this.physics.world.debugGraphic.visible;
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Done! Now walls and platforms have:
- **Light gray transparent fill** (12% opacity)
- **Diagonal crayon-like strokes** (subtle hatching)
- **Sketchy outline on top**

Refresh to see the new crayon-filled look!

---

**User**

double the darkness

---

**Cursor**

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style with crayon fill) ===
        const wallGraphics = this.add.graphics();
        
        // Left wall - fill first, then outline
        // Build path points for left wall
        const leftWallPoints = [{x: 55, y: 0}];
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            leftWallPoints.push({x: wobbleX, y: y});
        }
        leftWallPoints.push({x: 55, y: 795}, {x: 0, y: 795}, {x: 0, y: 0});
        
        // Fill left wall
        wallGraphics.fillStyle(0x888888, 0.24);
        wallGraphics.beginPath();
        wallGraphics.moveTo(leftWallPoints[0].x, leftWallPoints[0].y);
        for (let i = 1; i < leftWallPoints.length; i++) {
            wallGraphics.lineTo(leftWallPoints[i].x, leftWallPoints[i].y);
        }
        wallGraphics.closePath();
        wallGraphics.fillPath();
        
        // Crayon strokes for left wall
        wallGraphics.lineStyle(0.5, 0x666666, 0.15);
        for (let y = 0; y < 795; y += 8) {
            wallGraphics.beginPath();
            wallGraphics.moveTo((Math.random() - 0.5) * 2, y + (Math.random() - 0.5) * 2);
            wallGraphics.lineTo(50 + (Math.random() - 0.5) * 10, y + 15 + (Math.random() - 0.5) * 2);
            wallGraphics.strokePath();
        }
        
        // Outline left wall
        wallGraphics.lineStyle(2.5, 0x1a1a1a);
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let i = 1; i < leftWallPoints.length - 2; i++) {
            wallGraphics.lineTo(leftWallPoints[i].x, leftWallPoints[i].y);
        }
        wallGraphics.lineTo(55, 795);
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - fill first, then outline
        const rightWallPoints = [{x: 645, y: 0}];
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            rightWallPoints.push({x: wobbleX, y: y});
        }
        rightWallPoints.push({x: 645, y: 795}, {x: 700, y: 795}, {x: 700, y: 0});
        
        // Fill right wall
        wallGraphics.fillStyle(0x888888, 0.24);
        wallGraphics.beginPath();
        wallGraphics.moveTo(rightWallPoints[0].x, rightWallPoints[0].y);
        for (let i = 1; i < rightWallPoints.length; i++) {
            wallGraphics.lineTo(rightWallPoints[i].x, rightWallPoints[i].y);
        }
        wallGraphics.closePath();
        wallGraphics.fillPath();
        
        // Crayon strokes for right wall
        wallGraphics.lineStyle(0.5, 0x666666, 0.15);
        for (let y = 0; y < 795; y += 8) {
            wallGraphics.beginPath();
            wallGraphics.moveTo(650 + (Math.random() - 0.5) * 2, y + (Math.random() - 0.5) * 2);
            wallGraphics.lineTo(700 + (Math.random() - 0.5) * 2, y + 15 + (Math.random() - 0.5) * 2);
            wallGraphics.strokePath();
        }
        
        // Outline right wall
        wallGraphics.lineStyle(2.5, 0x1a1a1a);
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let i = 1; i < rightWallPoints.length - 2; i++) {
            wallGraphics.lineTo(rightWallPoints[i].x, rightWallPoints[i].y);
        }
        wallGraphics.lineTo(645, 795);
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (simple single wavy line) ===
        const waterGraphics = this.add.graphics();
        
        // Just one hand-drawn wavy line for water surface
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        
        // Create wavy line across the water surface
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterGraphics.lineTo(x, waveY);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.outlines) {
                    // Has multiple outline groups - draw each as connected shape
                    for (const outline of shapeData.outlines) {
                        // Crayon-like fill
                        g.fillStyle(0x888888, 0.24);
                        g.beginPath();
                        g.moveTo(outline[0].x + 3, outline[0].y + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + 3, outline[i].y + 3);
                        }
                        g.closePath();
                        g.fillPath();
                    }
                    
                    // Add crayon strokes across the whole shape
                    g.lineStyle(0.5, 0x666666, 0.15);
                    for (let y = 0; y < shapeData.height; y += 6) {
                        g.beginPath();
                        g.moveTo(3 + wobble(), y + 3 + wobble());
                        g.lineTo(Math.min(shapeData.width, y + 20) + 3 + wobble(), Math.min(shapeData.height, y + 20) + 3 + wobble());
                        g.strokePath();
                    }
                    g.lineStyle(2, 0x1a1a1a);
                    
                    // Draw outlines
                    for (const outline of shapeData.outlines) {
                        g.beginPath();
                        g.moveTo(outline[0].x + wobble() + 3, outline[0].y + wobble() + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + wobble() + 3, outline[i].y + wobble() + 3);
                        }
                        g.closePath();
                        g.strokePath();
                    }
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        // Crayon-like fill
                        g.fillStyle(0x888888, 0.24);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                    }
                    
                    // Add crayon strokes
                    g.lineStyle(0.5, 0x666666, 0.15);
                    for (let y = 0; y < shapeData.height; y += 6) {
                        g.beginPath();
                        g.moveTo(3 + wobble(), y + 3 + wobble());
                        g.lineTo(Math.min(shapeData.width, y + 20) + 3 + wobble(), Math.min(shapeData.height, y + 20) + 3 + wobble());
                        g.strokePath();
                    }
                    g.lineStyle(2, 0x1a1a1a);
                    
                    // Draw outlines
                    for (const part of shapeData.parts) {
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                // Crayon-like fill
                g.fillStyle(0x888888, 0.24);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
                
                // Add subtle diagonal crayon strokes
                g.lineStyle(0.5, 0x666666, 0.15);
                for (let y = 0; y < shapeData.height; y += 6) {
                    g.beginPath();
                    g.moveTo(3 + wobble(), y + 3 + wobble());
                    g.lineTo(Math.min(shapeData.width, y + 20) + 3 + wobble(), Math.min(shapeData.height, y + 20) + 3 + wobble());
                    g.strokePath();
                }
                g.lineStyle(2, 0x1a1a1a);  // Reset for outline
                
                // Outline
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R/G: restart/new | F: fly | H: hitbox', {
            fontSize: '9px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        // H key to toggle hitbox display
        this.hitboxKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.H);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        // Toggle hitbox debug display
        if (Phaser.Input.Keyboard.JustDown(this.hitboxKey)) {
            if (this.physics.world.debugGraphic) {
                this.physics.world.debugGraphic.visible = !this.physics.world.debugGraphic.visible;
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Done! Fill opacity doubled from 12% to 24%. Refresh to see the darker crayon fill.

---

**User**

can we do the same thing for the water but with blue

---

**Cursor**

```javascript
/**
 * PlayScene - Main gameplay scene
 * 
 * This is where the actual game happens. Phaser scenes have three main methods:
 * - preload(): Load assets (images, sounds, etc.)
 * - create(): Set up game objects, physics, input (runs once when scene starts)
 * - update(): Game loop, runs every frame (~60 times per second)
 */

class PlayScene extends Phaser.Scene {
    constructor() {
        super({ key: 'PlayScene' });
    }

    preload() {
        // Load the user-cropped notebook paper background (preserves scale)
        this.load.image('notebook-paper', 'assets/cropped-notebook-page.png');
    }

    create() {
        // === NOTEBOOK PAPER BACKGROUND (using cropped image) ===
        // Paper is pre-cropped to edges, just scale to fit canvas
        const paper = this.add.image(350, 450, 'notebook-paper');
        paper.setDisplaySize(700, 900);
        
        
        // === WALLS (hand-drawn style with crayon fill) ===
        const wallGraphics = this.add.graphics();
        
        // Left wall - fill first, then outline
        // Build path points for left wall
        const leftWallPoints = [{x: 55, y: 0}];
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 55 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.02) * 3;
            leftWallPoints.push({x: wobbleX, y: y});
        }
        leftWallPoints.push({x: 55, y: 795}, {x: 0, y: 795}, {x: 0, y: 0});
        
        // Fill left wall
        wallGraphics.fillStyle(0x888888, 0.24);
        wallGraphics.beginPath();
        wallGraphics.moveTo(leftWallPoints[0].x, leftWallPoints[0].y);
        for (let i = 1; i < leftWallPoints.length; i++) {
            wallGraphics.lineTo(leftWallPoints[i].x, leftWallPoints[i].y);
        }
        wallGraphics.closePath();
        wallGraphics.fillPath();
        
        // Crayon strokes for left wall
        wallGraphics.lineStyle(0.5, 0x666666, 0.15);
        for (let y = 0; y < 795; y += 8) {
            wallGraphics.beginPath();
            wallGraphics.moveTo((Math.random() - 0.5) * 2, y + (Math.random() - 0.5) * 2);
            wallGraphics.lineTo(50 + (Math.random() - 0.5) * 10, y + 15 + (Math.random() - 0.5) * 2);
            wallGraphics.strokePath();
        }
        
        // Outline left wall
        wallGraphics.lineStyle(2.5, 0x1a1a1a);
        wallGraphics.beginPath();
        wallGraphics.moveTo(55, 0);
        for (let i = 1; i < leftWallPoints.length - 2; i++) {
            wallGraphics.lineTo(leftWallPoints[i].x, leftWallPoints[i].y);
        }
        wallGraphics.lineTo(55, 795);
        wallGraphics.lineTo(0, 795);
        wallGraphics.strokePath();
        
        // Right wall - fill first, then outline
        const rightWallPoints = [{x: 645, y: 0}];
        for (let y = 0; y <= 795; y += 20) {
            const wobbleX = 645 + (Math.random() - 0.5) * 6 + Math.sin(y * 0.025 + 1) * 3;
            rightWallPoints.push({x: wobbleX, y: y});
        }
        rightWallPoints.push({x: 645, y: 795}, {x: 700, y: 795}, {x: 700, y: 0});
        
        // Fill right wall
        wallGraphics.fillStyle(0x888888, 0.24);
        wallGraphics.beginPath();
        wallGraphics.moveTo(rightWallPoints[0].x, rightWallPoints[0].y);
        for (let i = 1; i < rightWallPoints.length; i++) {
            wallGraphics.lineTo(rightWallPoints[i].x, rightWallPoints[i].y);
        }
        wallGraphics.closePath();
        wallGraphics.fillPath();
        
        // Crayon strokes for right wall
        wallGraphics.lineStyle(0.5, 0x666666, 0.15);
        for (let y = 0; y < 795; y += 8) {
            wallGraphics.beginPath();
            wallGraphics.moveTo(650 + (Math.random() - 0.5) * 2, y + (Math.random() - 0.5) * 2);
            wallGraphics.lineTo(700 + (Math.random() - 0.5) * 2, y + 15 + (Math.random() - 0.5) * 2);
            wallGraphics.strokePath();
        }
        
        // Outline right wall
        wallGraphics.lineStyle(2.5, 0x1a1a1a);
        wallGraphics.beginPath();
        wallGraphics.moveTo(645, 0);
        for (let i = 1; i < rightWallPoints.length - 2; i++) {
            wallGraphics.lineTo(rightWallPoints[i].x, rightWallPoints[i].y);
        }
        wallGraphics.lineTo(645, 795);
        wallGraphics.lineTo(700, 795);
        wallGraphics.strokePath();
        
        // Wall collision bodies (invisible rectangles)
        this.walls = this.physics.add.staticGroup();
        
        // Create wall collision textures (only if they don't exist)
        if (!this.textures.exists('wall')) {
            const wallTexture = this.add.graphics();
            wallTexture.fillStyle(0x000000, 0);  // Invisible
            wallTexture.fillRect(0, 0, 50, 795);
            wallTexture.generateTexture('wall', 50, 795);
            wallTexture.destroy();
        }
        
        // Add collision walls (positioned so player stays in play area)
        this.walls.create(27, 397, 'wall');   // Left wall
        this.walls.create(673, 397, 'wall');  // Right wall
        
        
        // === WATER HAZARD (with crayon-like blue fill) ===
        const waterGraphics = this.add.graphics();
        
        // Build wavy surface points
        const waterPoints = [{x: 0, y: 870}];
        for (let x = 0; x <= 700; x += 15) {
            const waveY = 870 + Math.sin(x * 0.05) * 4 + (Math.random() - 0.5) * 2;
            waterPoints.push({x: x, y: waveY});
        }
        
        // Blue crayon fill for water body
        waterGraphics.fillStyle(0x4A90D9, 0.24);
        waterGraphics.beginPath();
        waterGraphics.moveTo(0, 870);
        for (const pt of waterPoints) {
            waterGraphics.lineTo(pt.x, pt.y);
        }
        waterGraphics.lineTo(700, 900);  // bottom right
        waterGraphics.lineTo(0, 900);    // bottom left
        waterGraphics.closePath();
        waterGraphics.fillPath();
        
        // Crayon strokes for water
        waterGraphics.lineStyle(0.5, 0x2070B0, 0.2);
        for (let y = 872; y < 900; y += 5) {
            waterGraphics.beginPath();
            waterGraphics.moveTo((Math.random() - 0.5) * 4, y + (Math.random() - 0.5) * 2);
            waterGraphics.lineTo(700 + (Math.random() - 0.5) * 4, y + 8 + (Math.random() - 0.5) * 2);
            waterGraphics.strokePath();
        }
        
        // Wavy surface line
        waterGraphics.lineStyle(2, 0x4A90D9);  // Blue pen color
        waterGraphics.beginPath();
        waterGraphics.moveTo(waterPoints[0].x, waterPoints[0].y);
        for (let i = 1; i < waterPoints.length; i++) {
            waterGraphics.lineTo(waterPoints[i].x, waterPoints[i].y);
        }
        waterGraphics.strokePath();
        
        // Invisible zone for water collision detection (below the line)
        this.waterZone = this.add.zone(350, 885, 700, 30);
        this.physics.add.existing(this.waterZone, true);  // true = static body
        
        
        // === PLATFORMS (using shape library) ===
        this.platforms = this.physics.add.staticGroup();
        
        // Helper function to draw a sketchy shape
        this.createSketchyShape = (shapeName, shapeData) => {
            const g = this.add.graphics();
            const wobble = () => (Math.random() - 0.5) * 2;
            
            g.lineStyle(2, 0x1a1a1a);  // Dark pen color
            
            // Check if this is a compound shape (has parts array)
            if (shapeData.parts) {
                // Compound shape: check if it has custom visual outline (points) or just draw parts
                if (shapeData.outlines) {
                    // Has multiple outline groups - draw each as connected shape
                    for (const outline of shapeData.outlines) {
                        // Crayon-like fill
                        g.fillStyle(0x888888, 0.24);
                        g.beginPath();
                        g.moveTo(outline[0].x + 3, outline[0].y + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + 3, outline[i].y + 3);
                        }
                        g.closePath();
                        g.fillPath();
                    }
                    
                    // Add crayon strokes across the whole shape
                    g.lineStyle(0.5, 0x666666, 0.15);
                    for (let y = 0; y < shapeData.height; y += 6) {
                        g.beginPath();
                        g.moveTo(3 + wobble(), y + 3 + wobble());
                        g.lineTo(Math.min(shapeData.width, y + 20) + 3 + wobble(), Math.min(shapeData.height, y + 20) + 3 + wobble());
                        g.strokePath();
                    }
                    g.lineStyle(2, 0x1a1a1a);
                    
                    // Draw outlines
                    for (const outline of shapeData.outlines) {
                        g.beginPath();
                        g.moveTo(outline[0].x + wobble() + 3, outline[0].y + wobble() + 3);
                        for (let i = 1; i < outline.length; i++) {
                            g.lineTo(outline[i].x + wobble() + 3, outline[i].y + wobble() + 3);
                        }
                        g.closePath();
                        g.strokePath();
                    }
                } else {
                    // No custom outline - draw each part as separate rectangle
                    for (const part of shapeData.parts) {
                        // Crayon-like fill
                        g.fillStyle(0x888888, 0.24);
                        g.fillRect(part.x + 3, part.y + 3, part.w, part.h);
                    }
                    
                    // Add crayon strokes
                    g.lineStyle(0.5, 0x666666, 0.15);
                    for (let y = 0; y < shapeData.height; y += 6) {
                        g.beginPath();
                        g.moveTo(3 + wobble(), y + 3 + wobble());
                        g.lineTo(Math.min(shapeData.width, y + 20) + 3 + wobble(), Math.min(shapeData.height, y + 20) + 3 + wobble());
                        g.strokePath();
                    }
                    g.lineStyle(2, 0x1a1a1a);
                    
                    // Draw outlines
                    for (const part of shapeData.parts) {
                        g.beginPath();
                        g.moveTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + wobble() + 3);
                        g.lineTo(part.x + part.w + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + part.h + wobble() + 3);
                        g.lineTo(part.x + wobble() + 3, part.y + wobble() + 3);
                        g.strokePath();
                    }
                }
            } else {
                // Simple shape: draw from points array (original behavior)
                const points = shapeData.points;
                
                // Crayon-like fill
                g.fillStyle(0x888888, 0.24);
                g.beginPath();
                g.moveTo(points[0].x + 3, points[0].y + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + 3, points[i].y + 3);
                }
                g.closePath();
                g.fillPath();
                
                // Add subtle diagonal crayon strokes
                g.lineStyle(0.5, 0x666666, 0.15);
                for (let y = 0; y < shapeData.height; y += 6) {
                    g.beginPath();
                    g.moveTo(3 + wobble(), y + 3 + wobble());
                    g.lineTo(Math.min(shapeData.width, y + 20) + 3 + wobble(), Math.min(shapeData.height, y + 20) + 3 + wobble());
                    g.strokePath();
                }
                g.lineStyle(2, 0x1a1a1a);  // Reset for outline
                
                // Outline
                g.beginPath();
                g.moveTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                for (let i = 1; i < points.length; i++) {
                    g.lineTo(points[i].x + wobble() + 3, points[i].y + wobble() + 3);
                }
                g.lineTo(points[0].x + wobble() + 3, points[0].y + wobble() + 3);
                g.strokePath();
            }
            
            g.generateTexture(shapeName, shapeData.width + 6, shapeData.height + 6);
            g.destroy();
        };
        
        // Generate textures for all shapes in the library (only if they don't exist)
        for (const [name, data] of Object.entries(PLATFORM_SHAPES)) {
            if (!this.textures.exists(name)) {
                this.createSketchyShape(name, data);
            }
        }
        
        // Select level layout (use passed index or default to 0)
        this.currentLayoutIndex = (this.scene.settings.data && this.scene.settings.data.layoutIndex !== undefined) 
            ? this.scene.settings.data.layoutIndex 
            : 0;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex])
        
        
        // === PLAYER (hand-drawn stick figure - 0.75x original) ===
        if (!this.textures.exists('player')) {
            const playerGraphics = this.add.graphics();
            playerGraphics.lineStyle(1.5, 0x1a1a1a);  // Black pen
            
            // Simple stick figure: head, body, legs
            // Head (circle)
            playerGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 5.25);
            playerGraphics.lineTo(4.5, 10.5);
            playerGraphics.strokePath();
            // Arms (line across)
            playerGraphics.beginPath();
            playerGraphics.moveTo(1.5, 7.5);
            playerGraphics.lineTo(7.5, 7.5);
            playerGraphics.strokePath();
            // Legs (two lines)
            playerGraphics.beginPath();
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(2.25, 15);
            playerGraphics.moveTo(4.5, 10.5);
            playerGraphics.lineTo(6.75, 15);
            playerGraphics.strokePath();
            
            playerGraphics.generateTexture('player', 9, 17);
            playerGraphics.destroy();
        }
        
        // Create player with physics - start on the left bottom platform
        this.player = this.physics.add.sprite(100, 600, 'player');
        
        // Player physics properties
        this.player.setBounce(0.1);  // Tiny bounce when landing
        this.player.setCollideWorldBounds(true);  // Can't leave the screen
        
        // Make player collide with platforms
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        
        // Player dies if they touch water!
        this.physics.add.overlap(this.player, this.waterZone, this.playerDied, null, this);
        
        
        // === INPUT ===
        // Set up keyboard controls
        // createCursorKeys gives us arrow keys automatically
        this.cursors = this.input.keyboard.createCursorKeys();
        
        // Mouse input for shooting (and continuing after level complete)
        this.input.on('pointerdown', (pointer) => {
            if (this.levelInProgress) {
                this.shoot(pointer.x, pointer.y);
            } else {
                // Level is complete, click to start next level
                this.startNextLevel();
            }
        });
        
        
        // === BULLETS ===
        // === BULLET (hand-drawn dash) ===
        if (!this.textures.exists('bullet')) {
            const bulletGraphics = this.add.graphics();
            bulletGraphics.lineStyle(2, 0x1a1a1a);  // Black pen stroke
            bulletGraphics.beginPath();
            bulletGraphics.moveTo(0, 2);
            bulletGraphics.lineTo(8, 2);
            bulletGraphics.strokePath();
            bulletGraphics.generateTexture('bullet', 10, 4);
            bulletGraphics.destroy();
        }
        
        // Now create the group that uses the texture
        this.bullets = this.physics.add.group({
            defaultKey: 'bullet',
            maxSize: 20  // Limit bullets on screen
        });
        
        
        // === ENEMIES ===
        // === ENEMY (hand-drawn stick figure in red - 0.75x original) ===
        if (!this.textures.exists('enemy')) {
            const enemyGraphics = this.add.graphics();
            enemyGraphics.lineStyle(1.5, 0xcc3333);  // Red pen
            
            // Same stick figure shape as player
            // Head (circle)
            enemyGraphics.strokeCircle(4.5, 3, 2.25);
            // Body (line down)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 5.25);
            enemyGraphics.lineTo(4.5, 10.5);
            enemyGraphics.strokePath();
            // Arms (line across)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(1.5, 7.5);
            enemyGraphics.lineTo(7.5, 7.5);
            enemyGraphics.strokePath();
            // Legs (two lines)
            enemyGraphics.beginPath();
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(2.25, 15);
            enemyGraphics.moveTo(4.5, 10.5);
            enemyGraphics.lineTo(6.75, 15);
            enemyGraphics.strokePath();
            
            enemyGraphics.generateTexture('enemy', 9, 17);
            enemyGraphics.destroy();
        }
        
        // Create enemies group
        this.enemies = this.physics.add.group();
        
        // Spawn initial enemies on platforms
        this.spawnEnemy(450, 600);   // Bottom right platform
        this.spawnEnemy(280, 460);   // Middle platform
        this.spawnEnemy(380, 390);   // Row 4
        this.spawnEnemy(380, 250);   // Top platform
        
        // Make enemies collide with platforms (so they sit on them)
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Bullets hit enemies!
        this.physics.add.overlap(this.bullets, this.enemies, this.bulletHitEnemy, null, this);
        
        
        // === UI TEXT ===
        // Show some instructions (smaller for notebook canvas)
        this.add.text(60, 16, 'Arrows: move | Click: shoot | R/G: restart/new | F: fly | H: hitbox', {
            fontSize: '9px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // R key to restart the scene (reload same layout)
        this.restartKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R);
        // G key to generate new map (next layout)
        this.newMapKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.G);
        // F key to toggle fly mode (for testing)
        this.flyKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.F);
        this.flyMode = false;
        // H key to toggle hitbox display
        this.hitboxKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.H);
        
        // Enemy counter (positioned for notebook canvas)
        this.enemyCountText = this.add.text(60, 32, '', {
            fontSize: '11px',
            fill: '#333',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        this.updateEnemyCount();
        
        // Level complete text (hidden initially) - centered for 700px canvas
        this.levelCompleteText = this.add.text(350, 400, 'ðŸŽ‰ LEVEL COMPLETE! ðŸŽ‰', {
            fontSize: '28px',
            fill: '#fff',
            backgroundColor: '#228B22',
            padding: { x: 18, y: 10 }
        });
        this.levelCompleteText.setOrigin(0.5);
        this.levelCompleteText.setVisible(false);
        
        this.clickToContinueText = this.add.text(350, 460, 'Click to continue', {
            fontSize: '18px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 10, y: 5 }
        });
        this.clickToContinueText.setOrigin(0.5);
        this.clickToContinueText.setVisible(false);
        
        // Track current level and game state
        this.currentLevel = 1;
        this.levelInProgress = true;
        this.isRespawning = false;  // Prevents double-respawn bug
        
        // Level counter display
        this.levelText = this.add.text(610, 16, 'Level: 1', {
            fontSize: '16px',
            fill: '#000',
            backgroundColor: '#fff',
            padding: { x: 6, y: 3 }
        });
        
        // Layout number display (for debugging)
        this.layoutText = this.add.text(60, 48, `Layout: ${this.currentLayoutIndex + 1}/${LEVEL_LAYOUTS.length}`, {
            fontSize: '11px',
            fill: '#666',
            backgroundColor: 'rgba(255,255,255,0.8)',
            padding: { x: 4, y: 2 }
        });
        
        // Spawn points will be generated from the layout
        this.spawnPoints = [];
        
        // Player start position (will be set by layout)
        this.playerStartX = 100;
        this.playerStartY = 600;
    }
    
    /**
     * Load a level layout from the library
     */
    loadLayout(layout) {
        // Clear existing platforms
        this.platforms.clear(true, true);
        
        // Clear spawn points
        this.spawnPoints = [];
        
        // Create platforms from layout
        for (const plat of layout.platforms) {
            const shapeData = PLATFORM_SHAPES[plat.shape];
            
            // Check if this is a compound shape (has separate collision parts)
            if (shapeData.parts) {
                // Compound shape: create visual-only sprite + separate collision bodies
                
                // Add visual sprite (no physics)
                const visual = this.add.image(plat.x, plat.y, plat.shape);
                
                // Create collision bodies for each part
                for (const part of shapeData.parts) {
                    // Part coordinates are relative to shape origin (top-left)
                    // Convert to world position (plat.x, plat.y is center of shape)
                    const partX = plat.x - shapeData.width / 2 + part.x + part.w / 2;
                    const partY = plat.y - shapeData.height / 2 + part.y + part.h / 2;
                    
                    // Create invisible collision rectangle
                    const collider = this.add.rectangle(partX, partY, part.w, part.h, 0x000000, 0);
                    this.physics.add.existing(collider, true);  // true = static
                    this.platforms.add(collider);
                }
            } else {
                // Simple shape: single collision body (original behavior)
                const platform = this.platforms.create(plat.x, plat.y, plat.shape);
            }
            
            // Add this platform position as a spawn point
            // Spawn point is on top of the platform
            this.spawnPoints.push({
                x: plat.x,
                y: plat.y - shapeData.height / 2 - 15  // Above the platform
            });
        }
        
        // Set player start to first platform
        if (layout.platforms.length > 0) {
            const firstPlat = layout.platforms[0];
            const firstShape = PLATFORM_SHAPES[firstPlat.shape];
            this.playerStartX = firstPlat.x;
            this.playerStartY = firstPlat.y - firstShape.height / 2 - 15;
        }
    }
    
    /**
     * Spawn an enemy at a position
     */
    spawnEnemy(x, y) {
        const enemy = this.enemies.create(x, y, 'enemy');
        enemy.setBounce(0);
        enemy.setCollideWorldBounds(true);
    }
    
    /**
     * Called when a bullet hits an enemy
     */
    bulletHitEnemy(bullet, enemy) {
        // Deactivate the bullet
        bullet.setActive(false);
        bullet.setVisible(false);
        
        // Destroy the enemy
        enemy.destroy();
        
        // Update the counter
        this.updateEnemyCount();
        
        // Check for level complete
        if (this.enemies.countActive() === 0) {
            this.levelComplete();
        }
    }
    
    /**
     * Update the enemy count display
     */
    updateEnemyCount() {
        const count = this.enemies.countActive();
        this.enemyCountText.setText(`Enemies remaining: ${count}`);
    }
    
    /**
     * Called when all enemies are defeated
     */
    levelComplete() {
        this.levelInProgress = false;
        this.levelCompleteText.setVisible(true);
        this.clickToContinueText.setVisible(true);
    }
    
    /**
     * Start the next level - cycle through layouts and spawn enemies
     */
    startNextLevel() {
        this.currentLevel++;
        this.levelText.setText(`Level: ${this.currentLevel}`);
        
        // Hide completion messages
        this.levelCompleteText.setVisible(false);
        this.clickToContinueText.setVisible(false);
        
        // Clear any remaining bullets
        this.bullets.children.each((bullet) => {
            bullet.setActive(false);
            bullet.setVisible(false);
        });
        
        // Cycle to next layout (or random)
        this.currentLayoutIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
        this.loadLayout(LEVEL_LAYOUTS[this.currentLayoutIndex]);
        
        // Re-add platform and wall collisions
        this.physics.add.collider(this.player, this.platforms);
        this.physics.add.collider(this.player, this.walls);
        this.physics.add.collider(this.enemies, this.platforms);
        
        // Spawn enemies at random positions
        // More enemies as levels progress (4 + 1 per 2 levels, max based on spawn points)
        const enemyCount = Math.min(4 + Math.floor(this.currentLevel / 2), this.spawnPoints.length - 1);
        
        // Filter out player start position from spawn points for enemies
        const enemySpawnPoints = this.spawnPoints.filter(
            p => !(Math.abs(p.x - this.playerStartX) < 10 && Math.abs(p.y - this.playerStartY) < 10)
        );
        
        // Shuffle and pick
        const shuffled = Phaser.Utils.Array.Shuffle([...enemySpawnPoints]);
        for (let i = 0; i < enemyCount && i < shuffled.length; i++) {
            this.spawnEnemy(shuffled[i].x, shuffled[i].y);
        }
        
        this.updateEnemyCount();
        this.levelInProgress = true;
        
        // Reset player position - use body.reset for proper physics sync
        this.player.body.reset(this.playerStartX, this.playerStartY);
    }
    
    /**
     * Called when player touches water
     */
    playerDied() {
        // Prevent multiple triggers while respawning
        if (this.isRespawning) return;
        this.isRespawning = true;
        
        // Force physics body to fully reset at new position
        // This syncs sprite + physics body immediately to prevent desync
        this.player.body.reset(this.playerStartX, this.playerStartY);
        
        // Brief visual feedback - flash the player
        this.player.setTint(0xff0000);
        this.time.delayedCall(200, () => {
            this.player.clearTint();
        });
        
        // Clear respawn flag after player has time to land
        this.time.delayedCall(500, () => {
            this.isRespawning = false;
        });
    }

    update() {
        // This runs every frame - handle player movement here
        
        // Check for restart key (same layout)
        if (Phaser.Input.Keyboard.JustDown(this.restartKey)) {
            this.scene.restart({ layoutIndex: this.currentLayoutIndex });
            return;
        }
        
        // Check for new map key (next layout)
        if (Phaser.Input.Keyboard.JustDown(this.newMapKey)) {
            const nextIndex = (this.currentLayoutIndex + 1) % LEVEL_LAYOUTS.length;
            this.scene.restart({ layoutIndex: nextIndex });
            return;
        }
        
        // Toggle fly mode
        if (Phaser.Input.Keyboard.JustDown(this.flyKey)) {
            this.flyMode = !this.flyMode;
            this.player.body.allowGravity = !this.flyMode;
            if (this.flyMode) {
                this.player.setVelocity(0, 0);
            }
        }
        
        // Toggle hitbox debug display
        if (Phaser.Input.Keyboard.JustDown(this.hitboxKey)) {
            if (this.physics.world.debugGraphic) {
                this.physics.world.debugGraphic.visible = !this.physics.world.debugGraphic.visible;
            }
        }
        
        const speed = 120;  // Scaled down for smaller characters
        const flySpeed = 200;  // Speed when flying
        const jumpVelocity = -280;  // Scaled down - smaller jump for zoomed-out feel
        
        // Left/Right movement
        if (this.cursors.left.isDown) {
            this.player.setVelocityX(this.flyMode ? -flySpeed : -speed);
        } else if (this.cursors.right.isDown) {
            this.player.setVelocityX(this.flyMode ? flySpeed : speed);
        } else {
            // No arrow pressed - stop horizontal movement
            this.player.setVelocityX(0);
        }
        
        // Up/Down movement (fly mode) or jumping (normal mode)
        if (this.flyMode) {
            // Fly mode: up/down arrows move vertically
            if (this.cursors.up.isDown) {
                this.player.setVelocityY(-flySpeed);
            } else if (this.cursors.down.isDown) {
                this.player.setVelocityY(flySpeed);
            } else {
                this.player.setVelocityY(0);
            }
        } else {
            // Normal mode: jumping when touching ground
            if (this.cursors.up.isDown && this.player.body.blocked.down) {
                this.player.setVelocityY(jumpVelocity);
            }
        }
        
        // Clean up bullets that have left the screen
        this.bullets.children.each((bullet) => {
            if (bullet.active && (bullet.x < -50 || bullet.x > 750 || bullet.y < -50 || bullet.y > 950)) {
                bullet.setActive(false);
                bullet.setVisible(false);
            }
        });
    }
    
    /**
     * Shoot a bullet toward a target position
     * @param {number} targetX - X coordinate to shoot toward
     * @param {number} targetY - Y coordinate to shoot toward
     */
    shoot(targetX, targetY) {
        // Get a bullet from the group (reuses inactive bullets)
        const bullet = this.bullets.get(this.player.x, this.player.y);
        
        if (!bullet) return;  // No bullets available
        
        bullet.setActive(true);
        bullet.setVisible(true);
        
        // Calculate direction to target
        const angle = Phaser.Math.Angle.Between(
            this.player.x, this.player.y,
            targetX, targetY
        );
        
        // Set bullet velocity toward target
        const bulletSpeed = 600;
        bullet.setVelocity(
            Math.cos(angle) * bulletSpeed,
            Math.sin(angle) * bulletSpeed
        );
        
        // Rotate bullet to face direction of travel
        bullet.setRotation(angle);
        
        // Bullets shouldn't be affected by gravity
        bullet.body.allowGravity = false;
    }
}


```

Done! Water now has:
- **Light blue fill** (same 24% opacity as walls/platforms)
- **Horizontal crayon strokes** (slightly darker blue)
- **Wavy surface line** on top

Refresh to see the blue crayon water!

---

**User**

ok now can you do what we did with the drawing/hitboxes for the horizontal columns shape?

---

**Cursor**

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array - both visual AND collision are drawn from parts
    // Each part is a rectangle: { x, y, w, h } relative to shape origin
    
    // Shape #1: Vertical slot - two pillars with drop-through gap
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    verticalSlot: {
        width: 60,
        height: 60,
        parts: [
            { x: 0, y: 0, w: 20, h: 60 },     // left pillar
            { x: 40, y: 0, w: 20, h: 60 }     // right pillar (20px gap between)
        ]
    },
    
    // Shape #2: Horizontal tunnel - walk-through passage
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆ    â–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    horizontalTunnel: {
        width: 70,
        height: 50,
        parts: [
            { x: 0, y: 0, w: 70, h: 15 },     // top bar
            { x: 0, y: 15, w: 10, h: 20 },    // left wall
            { x: 60, y: 15, w: 10, h: 20 },   // right wall
            { x: 0, y: 35, w: 70, h: 15 }     // bottom bar
        ],
        // Custom outlines: outer rectangle + inner tunnel hole
        outlines: [
            // Outer perimeter (clockwise)
            [
                {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 50}, {x: 0, y: 50}
            ],
            // Inner tunnel hole (shows the passage)
            [
                {x: 10, y: 15}, {x: 60, y: 15}, {x: 60, y: 35}, {x: 10, y: 35}
            ]
        ]
    },
    
    // Shape #3: Zig-zag gap - diagonal drop-through (two L-shapes)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆâ–ˆ
    // â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    zigZagGap: {
        width: 60,
        height: 80,
        parts: [
            { x: 0, y: 0, w: 60, h: 15 },     // top bar
            { x: 0, y: 15, w: 15, h: 30 },    // left stem
            { x: 45, y: 35, w: 15, h: 30 },   // right stem
            { x: 0, y: 65, w: 60, h: 15 }     // bottom bar
        ],
        // Custom outlines: two L-shapes drawn separately
        outlines: [
            // Top L-shape (top bar + left stem)
            [
                {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 15}, {x: 15, y: 15},
                {x: 15, y: 45}, {x: 0, y: 45}
            ],
            // Bottom inverted-L (right stem + bottom bar)
            [
                {x: 45, y: 35}, {x: 60, y: 35}, {x: 60, y: 80}, {x: 0, y: 80},
                {x: 0, y: 65}, {x: 45, y: 65}
            ]
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! `horizontalTunnel` now has custom outlines:
- **Outer rectangle** - the block perimeter
- **Inner rectangle** - shows the tunnel passage

Press R to test - it should look like one solid block with a hole through it, not 4 separate boxes!

---

**User**

you just turned it into a hollow box. its suppose to be like 2 layers stacked with a tunnel horizontal

---

**Cursor**

```plaintext
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (top bar)

â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ  (bottom bar)
```

Ah, I see! It should be two horizontal bars with an open tunnel between them - you can walk through from side to side. Let me fix both the collision and visual:

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * Scaled based on reference image with stick figure:
 * - Stick figure is ~12x22 pixels
 * - Flat platforms are thin (~8-10px tall)
 * - Long platforms are ~100-120px wide
 * - Tall blocks are ~50-80px tall
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array - both visual AND collision are drawn from parts
    // Each part is a rectangle: { x, y, w, h } relative to shape origin
    
    // Shape #1: Vertical slot - two pillars with drop-through gap
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    verticalSlot: {
        width: 60,
        height: 60,
        parts: [
            { x: 0, y: 0, w: 20, h: 60 },     // left pillar
            { x: 40, y: 0, w: 20, h: 60 }     // right pillar (20px gap between)
        ]
    },
    
    // Shape #2: Horizontal tunnel - two bars stacked with walk-through gap
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    //           (gap - walk through here)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    horizontalTunnel: {
        width: 70,
        height: 50,
        parts: [
            { x: 0, y: 0, w: 70, h: 15 },     // top bar
            { x: 0, y: 35, w: 70, h: 15 }     // bottom bar
        ],
        // Two separate horizontal bars
        outlines: [
            // Top bar
            [
                {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 15}, {x: 0, y: 15}
            ],
            // Bottom bar
            [
                {x: 0, y: 35}, {x: 70, y: 35}, {x: 70, y: 50}, {x: 0, y: 50}
            ]
        ]
    },
    
    // Shape #3: Zig-zag gap - diagonal drop-through (two L-shapes)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆâ–ˆ
    // â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    zigZagGap: {
        width: 60,
        height: 80,
        parts: [
            { x: 0, y: 0, w: 60, h: 15 },     // top bar
            { x: 0, y: 15, w: 15, h: 30 },    // left stem
            { x: 45, y: 35, w: 15, h: 30 },   // right stem
            { x: 0, y: 65, w: 60, h: 15 }     // bottom bar
        ],
        // Custom outlines: two L-shapes drawn separately
        outlines: [
            // Top L-shape (top bar + left stem)
            [
                {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 15}, {x: 15, y: 15},
                {x: 15, y: 45}, {x: 0, y: 45}
            ],
            // Bottom inverted-L (right stem + bottom bar)
            [
                {x: 45, y: 35}, {x: 60, y: 35}, {x: 60, y: 80}, {x: 0, y: 80},
                {x: 0, y: 65}, {x: 45, y: 65}
            ]
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Fixed! Now `horizontalTunnel` is:
- **Two bars** stacked with a gap between
- **No side walls** - open on left and right to walk through
- Visual shows two separate rectangular bars

Press R to test - you should be able to walk/fly through the horizontal gap between the bars!

---

**User**

perfect work. lets keep going now. what was next?

---

**Cursor**

Great progress! We have 3 compound shapes now:
1. âœ… `verticalSlot` - two pillars, drop through middle
2. âœ… `horizontalTunnel` - two bars, walk through gap
3. âœ… `zigZagGap` - two L-shapes, diagonal drop

You mentioned wanting **4-5 compound shapes** before building the generator. Want me to:

**A)** Add 1-2 more compound shapes? Ideas:
- `cornerBlock` - L-shaped piece (solid L, no gap)
- `stairStep` - two blocks in stair arrangement
- `bridgeGap` - like horizontalTunnel but narrower

**B)** Or move straight to the **procedural layout generator**?

---

**User**

is the generator just gonna pull from this preset list of shapes? if so i think we should have way more shapes

---

**Cursor**

Good question! The generator could work a few ways:

**Option 1: Pull from preset shapes** (current approach)
- More shapes = more variety
- Predictable, easy to tune
- But yes, we'd want many more shapes

**Option 2: Shape variations** (recommended)
- Take existing shapes and apply variations:
  - **Flip horizontally** (lShapeDownRight becomes lShapeDownLeft automatically)
  - **Scale** (flatLong at 80%, 100%, 120%)
- This multiplies our 18 shapes into 50+ variations

**Option 3: Procedural shape generation**
- Generate random polygon shapes on the fly
- Infinite variety but harder to control quality/balance

I'd suggest **Option 2** - add flipping and scaling to the existing shapes. This gives us tons of variety without manually defining dozens more shapes.

We could also add maybe **5-10 more base shapes** for more interesting variety, then the flip/scale variations multiply it.

What sounds right to you?

---

**User**

i think we could do more shapes. i also think we could benefit from having some kind of semi dynamic application of holes or tunnels or caves to existing. shapes. maybe thats a further out goal. but for now lets document everything ive suggested and checkpoint again

---

**Cursor**

```markdown
# Current Context for New Chat

## Project Status: Layout System & Visual Polish Complete, Generator Next

A stick figure arena shooter built with Phaser 3, styled to look like doodles on crumpled notebook paper. Layout 1 is tuned with three-zone structure. Compound shapes working. Ready for more shapes and generator.

## What Works

- **Player movement:** Arrow keys to move left/right, up to jump
- **Shooting:** Click to fire toward mouse cursor
- **Enemies:** Red stick figures placed on platforms, destroyed when shot
- **Level progression:** Complete a level by shooting all enemies, click to continue
- **Level layouts:** 5 layouts (Layout 1 has new 3-zone structure, others old style)
- **Platform shape library:** 15 simple shapes + 3 compound shapes
- **Compound shape system:** Shapes with multiple collision bodies and custom visual outlines
- **Water hazard:** Blue wavy line with crayon fill at y=870
- **Walls:** Hand-drawn irregular walls with crayon fill, ending at y=795 with horizontal caps
- **Notebook paper background:** Crumpled paper image
- **Hand-drawn aesthetic:** Crayon-like gray fill on all platforms/walls, sketchy outlines
- **Debug controls:**
  - R = restart same layout
  - G = next layout (cycles 1-5)
  - F = toggle fly mode (no gravity, 4-direction movement)
  - H = toggle hitbox debug display

## Shape Library

### Simple Shapes (15)
Defined with `points` array for visual outline, single collision body.

**Flat platforms:** flatLong (120x8), flatMedium (70x8), flatSmall (40x8), flatTiny (25x8)
**L-shapes:** lShapeDownRight (70x35), lShapeDownLeft (70x35)
**Blocks:** blockTall (35x65), blockWide (55x50), blockShort (40x30)
**Special:** tShape (40x25), pillar (18x45), cupShape (30x20), rock (25x16), bumpyWide (100x15), notchedBlock (50x55)

### Compound Shapes (3)
Defined with `parts` array for multiple collision bodies + `outlines` array for connected visual.

**verticalSlot** (60x60) - Two pillars with 20px drop-through gap
**horizontalTunnel** (70x50) - Two horizontal bars with walk-through gap
**zigZagGap** (60x80) - Two L-shapes arranged diagonally with drop-through passage

## Layout Design System

### Three-Zone Structure (see PlatformShapes.js for full rules)

**LEFT COLUMN (x ~120-160, edge at x=100)**
- Stacked horizontal platforms forming "tiers"
- Mostly flatLong shapes, some flatMedium
- ~8-9 tiers, ~70-85px spacing (varied, NOT uniform)
- Platforms aligned so left edge is consistent (~45px gap from wall)

**RIGHT COLUMN (x ~540-580, edge at x=600)**
- Mirror concept but NOT symmetrical to left
- Different tier count, Y positions offset from left
- Platforms aligned so right edge is consistent (~45px gap from wall)

**CENTER ZONE (x ~260-440)**
- Open area with scattered SMALL shapes
- Types: rock, flatSmall, flatTiny, tShape, pillar, cupShape, compound shapes
- Sparse, organic placement at varied heights

### Drop Corridors
- ~45px gap between wall and nearest platform edge
- Allows player to drop straight down along walls

## Visual Style

- **Crayon fill:** 24% opacity gray (0x888888) on platforms/walls, blue on water
- **Diagonal hatching:** Subtle crayon strokes across filled shapes
- **Sketchy outlines:** Wobble effect on all drawn lines
- **Hand-drawn walls:** Irregular vertical lines with wobble

## File Structure

```
stick-game-test/
â”œâ”€â”€ index.html
â”œâ”€â”€ js/
â”‚   â”œâ”€â”€ game.js                   # Phaser config (700x900, debug: true)
â”‚   â”œâ”€â”€ platforms/
â”‚   â”‚   â””â”€â”€ PlatformShapes.js     # Shape definitions + layout rules + 5 layouts
â”‚   â””â”€â”€ scenes/
â”‚       â””â”€â”€ PlayScene.js          # Main gameplay, drawing, physics
â”œâ”€â”€ assets/
â”‚   â””â”€â”€ cropped-notebook-page.png
â”œâ”€â”€ reference/
â”‚   â”œâ”€â”€ example-map.png           # Original layout reference
â”‚   â”œâ”€â”€ example-map-2.png
â”‚   â””â”€â”€ layout-ref-1.png          # Screenshot of current Layout 1
â””â”€â”€ ai-context-management/
```

## Technical Notes

- Phaser 3.70.0 via CDN
- Canvas: 700x900
- Arcade Physics with gravity (800)
- Walls at x=55 (left) and x=645 (right), end at y=795
- Water line at y=870
- Character size: 9x17 pixels (0.75x original)
- Run with `python3 -m http.server 8000`

## Future Goals (Documented Ideas)

### Near-term: More Shapes
- Add 5-10 more base shapes for variety
- Consider shape variations: horizontal flip, scaling

### Medium-term: Dynamic Holes/Tunnels
- System to dynamically apply holes, tunnels, or caves to existing shapes
- Could turn any solid block into a tunnel/cave variant
- Adds massive variety without manually defining every combination

### Then: Procedural Layout Generator
- Generate layouts following the three-zone rules
- Pull from shape library with flip/scale variations
- Place compound shapes in center zone
- Ensure playability (reachable platforms, spawn points)

## Recent Changes (This Session)

1. Character size reduced to 0.75x (9x17 pixels)
2. Water simplified to single line at y=870 with blue crayon fill
3. Wall bottoms raised to y=795 with horizontal caps
4. Layout 1 redesigned with three-zone structure
5. Added compound shape system (parts + outlines)
6. Created 3 compound shapes: verticalSlot, horizontalTunnel, zigZagGap
7. Added crayon-like fill to all platforms, walls, and water
8. Added debug controls: R (restart), G (new map), F (fly), H (hitboxes)
9. Fixed texture stacking bug on restart
10. Documented layout design rules extensively

## Known Issues

- Layouts 2-5 still have old structure (need generator to replace them)
- All else working as expected

```

```markdown
# Current Work Focus

Layout 1 tuned. Compound shape system working (3 shapes). Crayon visual style complete. Debug controls in place. Ready to expand shape library, then build procedural generator.

- **Project Goal:** Build a browser-based stick figure arena shooter with random level generation (Worms-style vibes, notebook paper aesthetic)

- **Intermediate Goal:** Expand shape library and build procedural layout generator

- **Current Task:** Add more base shapes to the library, then implement generator using documented three-zone rules

## Queued Ideas (User Suggestions)

1. **More shapes** - Add 5-10 more base shapes for variety
2. **Shape variations** - Horizontal flip, scaling of existing shapes
3. **Dynamic holes/tunnels** - System to apply holes/caves to existing shapes dynamically (further out goal)

```

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * SHAPE TYPES:
 * 
 * 1. SIMPLE SHAPES (15 total)
 *    - Defined with `points` array (polygon outline)
 *    - Single collision body matching the shape
 *    - Examples: flatLong, blockTall, lShapeDownRight
 * 
 * 2. COMPOUND SHAPES (3 total)
 *    - Defined with `parts` array (multiple collision rectangles)
 *    - Optional `outlines` array for connected visual appearance
 *    - Have passable gaps/tunnels between collision parts
 *    - Examples: verticalSlot, horizontalTunnel, zigZagGap
 * 
 * SCALING (based on reference with stick figure):
 * - Stick figure: 9x17 pixels (0.75x original)
 * - Flat platforms: ~8px tall
 * - Long platforms: ~100-120px wide
 * - Tall blocks: ~50-80px tall
 * 
 * FUTURE GOALS:
 * - Add more base shapes (5-10 more)
 * - Shape variations: horizontal flip, scaling
 * - Dynamic hole/tunnel system: apply caves/passages to any solid shape
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array - both visual AND collision are drawn from parts
    // Each part is a rectangle: { x, y, w, h } relative to shape origin
    
    // Shape #1: Vertical slot - two pillars with drop-through gap
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    verticalSlot: {
        width: 60,
        height: 60,
        parts: [
            { x: 0, y: 0, w: 20, h: 60 },     // left pillar
            { x: 40, y: 0, w: 20, h: 60 }     // right pillar (20px gap between)
        ]
    },
    
    // Shape #2: Horizontal tunnel - two bars stacked with walk-through gap
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    //           (gap - walk through here)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    horizontalTunnel: {
        width: 70,
        height: 50,
        parts: [
            { x: 0, y: 0, w: 70, h: 15 },     // top bar
            { x: 0, y: 35, w: 70, h: 15 }     // bottom bar
        ],
        // Two separate horizontal bars
        outlines: [
            // Top bar
            [
                {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 15}, {x: 0, y: 15}
            ],
            // Bottom bar
            [
                {x: 0, y: 35}, {x: 70, y: 35}, {x: 70, y: 50}, {x: 0, y: 50}
            ]
        ]
    },
    
    // Shape #3: Zig-zag gap - diagonal drop-through (two L-shapes)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆâ–ˆ
    // â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    zigZagGap: {
        width: 60,
        height: 80,
        parts: [
            { x: 0, y: 0, w: 60, h: 15 },     // top bar
            { x: 0, y: 15, w: 15, h: 30 },    // left stem
            { x: 45, y: 35, w: 15, h: 30 },   // right stem
            { x: 0, y: 65, w: 60, h: 15 }     // bottom bar
        ],
        // Custom outlines: two L-shapes drawn separately
        outlines: [
            // Top L-shape (top bar + left stem)
            [
                {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 15}, {x: 15, y: 15},
                {x: 15, y: 45}, {x: 0, y: 45}
            ],
            // Bottom inverted-L (right stem + bottom bar)
            [
                {x: 45, y: 35}, {x: 60, y: 35}, {x: 60, y: 80}, {x: 0, y: 80},
                {x: 0, y: 65}, {x: 45, y: 65}
            ]
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

**Checkpoint complete!** Here's what's documented:

### Current State
- âœ… 15 simple shapes + 3 compound shapes  
- âœ… Layout 1 with three-zone structure
- âœ… Crayon-style fills on everything
- âœ… Debug controls (R/G/F/H)
- âœ… Compound shape system working

### Documented Future Goals

**Near-term:**
1. Add more base shapes (5-10 more)
2. Shape variations (flip, scale)

**Medium-term:**
3. Procedural layout generator

**Further out:**
4. Dynamic holes/tunnels system - apply passages to any solid shape

### Files Updated
- `current-context-for-new-chat.md` - Full project state
- `current-work-focus.md` - Next steps and queued ideas
- `PlatformShapes.js` - Header updated with shape system docs and future goals

Ready to continue when you are! What's next - more shapes?

---

**User**

can you add a layout like insert one at layout 2 so we have 6 total. on that one just display every existing shape/platform?

---

**Cursor**

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * SHAPE TYPES:
 * 
 * 1. SIMPLE SHAPES (15 total)
 *    - Defined with `points` array (polygon outline)
 *    - Single collision body matching the shape
 *    - Examples: flatLong, blockTall, lShapeDownRight
 * 
 * 2. COMPOUND SHAPES (3 total)
 *    - Defined with `parts` array (multiple collision rectangles)
 *    - Optional `outlines` array for connected visual appearance
 *    - Have passable gaps/tunnels between collision parts
 *    - Examples: verticalSlot, horizontalTunnel, zigZagGap
 * 
 * SCALING (based on reference with stick figure):
 * - Stick figure: 9x17 pixels (0.75x original)
 * - Flat platforms: ~8px tall
 * - Long platforms: ~100-120px wide
 * - Tall blocks: ~50-80px tall
 * 
 * FUTURE GOALS:
 * - Add more base shapes (5-10 more)
 * - Shape variations: horizontal flip, scaling
 * - Dynamic hole/tunnel system: apply caves/passages to any solid shape
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array - both visual AND collision are drawn from parts
    // Each part is a rectangle: { x, y, w, h } relative to shape origin
    
    // Shape #1: Vertical slot - two pillars with drop-through gap
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    verticalSlot: {
        width: 60,
        height: 60,
        parts: [
            { x: 0, y: 0, w: 20, h: 60 },     // left pillar
            { x: 40, y: 0, w: 20, h: 60 }     // right pillar (20px gap between)
        ]
    },
    
    // Shape #2: Horizontal tunnel - two bars stacked with walk-through gap
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    //           (gap - walk through here)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    horizontalTunnel: {
        width: 70,
        height: 50,
        parts: [
            { x: 0, y: 0, w: 70, h: 15 },     // top bar
            { x: 0, y: 35, w: 70, h: 15 }     // bottom bar
        ],
        // Two separate horizontal bars
        outlines: [
            // Top bar
            [
                {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 15}, {x: 0, y: 15}
            ],
            // Bottom bar
            [
                {x: 0, y: 35}, {x: 70, y: 35}, {x: 70, y: 50}, {x: 0, y: 50}
            ]
        ]
    },
    
    // Shape #3: Zig-zag gap - diagonal drop-through (two L-shapes)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆâ–ˆ
    // â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    zigZagGap: {
        width: 60,
        height: 80,
        parts: [
            { x: 0, y: 0, w: 60, h: 15 },     // top bar
            { x: 0, y: 15, w: 15, h: 30 },    // left stem
            { x: 45, y: 35, w: 15, h: 30 },   // right stem
            { x: 0, y: 65, w: 60, h: 15 }     // bottom bar
        ],
        // Custom outlines: two L-shapes drawn separately
        outlines: [
            // Top L-shape (top bar + left stem)
            [
                {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 15}, {x: 15, y: 15},
                {x: 15, y: 45}, {x: 0, y: 45}
            ],
            // Bottom inverted-L (right stem + bottom bar)
            [
                {x: 45, y: 35}, {x: 60, y: 35}, {x: 60, y: 80}, {x: 0, y: 80},
                {x: 0, y: 65}, {x: 45, y: 65}
            ]
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2 - SHAPE SHOWCASE (displays all 18 shapes)
    {
        name: "showcase",
        platforms: [
            // Row 1 (y=780): Flat platforms - spawn on first one
            { shape: 'flatLong', x: 150, y: 780 },
            { shape: 'flatMedium', x: 300, y: 780 },
            { shape: 'flatSmall', x: 420, y: 780 },
            { shape: 'flatTiny', x: 520, y: 780 },
            
            // Row 2 (y=680): L-shapes and blocks
            { shape: 'lShapeDownRight', x: 140, y: 680 },
            { shape: 'lShapeDownLeft', x: 280, y: 680 },
            { shape: 'blockTall', x: 400, y: 680 },
            { shape: 'blockWide', x: 500, y: 680 },
            
            // Row 3 (y=570): More blocks and special shapes
            { shape: 'blockShort', x: 140, y: 570 },
            { shape: 'tShape', x: 250, y: 570 },
            { shape: 'pillar', x: 350, y: 570 },
            { shape: 'cupShape', x: 440, y: 570 },
            { shape: 'rock', x: 530, y: 570 },
            
            // Row 4 (y=450): Remaining simple shapes
            { shape: 'bumpyWide', x: 200, y: 450 },
            { shape: 'notchedBlock', x: 400, y: 450 },
            
            // Row 5 (y=320): Compound shapes with gaps
            { shape: 'verticalSlot', x: 150, y: 320 },
            { shape: 'horizontalTunnel', x: 300, y: 320 },
            { shape: 'zigZagGap', x: 480, y: 320 },
            
            // Top platform for reference
            { shape: 'flatLong', x: 350, y: 180 }
        ]
    },
    
    // Layout 3 (was Layout 2)
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 3
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * SHAPE TYPES:
 * 
 * 1. SIMPLE SHAPES (15 total)
 *    - Defined with `points` array (polygon outline)
 *    - Single collision body matching the shape
 *    - Examples: flatLong, blockTall, lShapeDownRight
 * 
 * 2. COMPOUND SHAPES (3 total)
 *    - Defined with `parts` array (multiple collision rectangles)
 *    - Optional `outlines` array for connected visual appearance
 *    - Have passable gaps/tunnels between collision parts
 *    - Examples: verticalSlot, horizontalTunnel, zigZagGap
 * 
 * SCALING (based on reference with stick figure):
 * - Stick figure: 9x17 pixels (0.75x original)
 * - Flat platforms: ~8px tall
 * - Long platforms: ~100-120px wide
 * - Tall blocks: ~50-80px tall
 * 
 * FUTURE GOALS:
 * - Add more base shapes (5-10 more)
 * - Shape variations: horizontal flip, scaling
 * - Dynamic hole/tunnel system: apply caves/passages to any solid shape
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array - both visual AND collision are drawn from parts
    // Each part is a rectangle: { x, y, w, h } relative to shape origin
    
    // Shape #1: Vertical slot - two pillars with drop-through gap
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    verticalSlot: {
        width: 60,
        height: 60,
        parts: [
            { x: 0, y: 0, w: 20, h: 60 },     // left pillar
            { x: 40, y: 0, w: 20, h: 60 }     // right pillar (20px gap between)
        ]
    },
    
    // Shape #2: Horizontal tunnel - two bars stacked with walk-through gap
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    //           (gap - walk through here)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    horizontalTunnel: {
        width: 70,
        height: 50,
        parts: [
            { x: 0, y: 0, w: 70, h: 15 },     // top bar
            { x: 0, y: 35, w: 70, h: 15 }     // bottom bar
        ],
        // Two separate horizontal bars
        outlines: [
            // Top bar
            [
                {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 15}, {x: 0, y: 15}
            ],
            // Bottom bar
            [
                {x: 0, y: 35}, {x: 70, y: 35}, {x: 70, y: 50}, {x: 0, y: 50}
            ]
        ]
    },
    
    // Shape #3: Zig-zag gap - diagonal drop-through (two L-shapes)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆâ–ˆ
    // â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    zigZagGap: {
        width: 60,
        height: 80,
        parts: [
            { x: 0, y: 0, w: 60, h: 15 },     // top bar
            { x: 0, y: 15, w: 15, h: 30 },    // left stem
            { x: 45, y: 35, w: 15, h: 30 },   // right stem
            { x: 0, y: 65, w: 60, h: 15 }     // bottom bar
        ],
        // Custom outlines: two L-shapes drawn separately
        outlines: [
            // Top L-shape (top bar + left stem)
            [
                {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 15}, {x: 15, y: 15},
                {x: 15, y: 45}, {x: 0, y: 45}
            ],
            // Bottom inverted-L (right stem + bottom bar)
            [
                {x: 45, y: 35}, {x: 60, y: 35}, {x: 60, y: 80}, {x: 0, y: 80},
                {x: 0, y: 65}, {x: 45, y: 65}
            ]
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2 - SHAPE SHOWCASE (displays all 18 shapes)
    {
        name: "showcase",
        platforms: [
            // Row 1 (y=780): Flat platforms - spawn on first one
            { shape: 'flatLong', x: 150, y: 780 },
            { shape: 'flatMedium', x: 300, y: 780 },
            { shape: 'flatSmall', x: 420, y: 780 },
            { shape: 'flatTiny', x: 520, y: 780 },
            
            // Row 2 (y=680): L-shapes and blocks
            { shape: 'lShapeDownRight', x: 140, y: 680 },
            { shape: 'lShapeDownLeft', x: 280, y: 680 },
            { shape: 'blockTall', x: 400, y: 680 },
            { shape: 'blockWide', x: 500, y: 680 },
            
            // Row 3 (y=570): More blocks and special shapes
            { shape: 'blockShort', x: 140, y: 570 },
            { shape: 'tShape', x: 250, y: 570 },
            { shape: 'pillar', x: 350, y: 570 },
            { shape: 'cupShape', x: 440, y: 570 },
            { shape: 'rock', x: 530, y: 570 },
            
            // Row 4 (y=450): Remaining simple shapes
            { shape: 'bumpyWide', x: 200, y: 450 },
            { shape: 'notchedBlock', x: 400, y: 450 },
            
            // Row 5 (y=320): Compound shapes with gaps
            { shape: 'verticalSlot', x: 150, y: 320 },
            { shape: 'horizontalTunnel', x: 300, y: 320 },
            { shape: 'zigZagGap', x: 480, y: 320 },
            
            // Top platform for reference
            { shape: 'flatLong', x: 350, y: 180 }
        ]
    },
    
    // Layout 3 (was Layout 2)
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 4 (was Layout 3)
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 4
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * SHAPE TYPES:
 * 
 * 1. SIMPLE SHAPES (15 total)
 *    - Defined with `points` array (polygon outline)
 *    - Single collision body matching the shape
 *    - Examples: flatLong, blockTall, lShapeDownRight
 * 
 * 2. COMPOUND SHAPES (3 total)
 *    - Defined with `parts` array (multiple collision rectangles)
 *    - Optional `outlines` array for connected visual appearance
 *    - Have passable gaps/tunnels between collision parts
 *    - Examples: verticalSlot, horizontalTunnel, zigZagGap
 * 
 * SCALING (based on reference with stick figure):
 * - Stick figure: 9x17 pixels (0.75x original)
 * - Flat platforms: ~8px tall
 * - Long platforms: ~100-120px wide
 * - Tall blocks: ~50-80px tall
 * 
 * FUTURE GOALS:
 * - Add more base shapes (5-10 more)
 * - Shape variations: horizontal flip, scaling
 * - Dynamic hole/tunnel system: apply caves/passages to any solid shape
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array - both visual AND collision are drawn from parts
    // Each part is a rectangle: { x, y, w, h } relative to shape origin
    
    // Shape #1: Vertical slot - two pillars with drop-through gap
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    verticalSlot: {
        width: 60,
        height: 60,
        parts: [
            { x: 0, y: 0, w: 20, h: 60 },     // left pillar
            { x: 40, y: 0, w: 20, h: 60 }     // right pillar (20px gap between)
        ]
    },
    
    // Shape #2: Horizontal tunnel - two bars stacked with walk-through gap
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    //           (gap - walk through here)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    horizontalTunnel: {
        width: 70,
        height: 50,
        parts: [
            { x: 0, y: 0, w: 70, h: 15 },     // top bar
            { x: 0, y: 35, w: 70, h: 15 }     // bottom bar
        ],
        // Two separate horizontal bars
        outlines: [
            // Top bar
            [
                {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 15}, {x: 0, y: 15}
            ],
            // Bottom bar
            [
                {x: 0, y: 35}, {x: 70, y: 35}, {x: 70, y: 50}, {x: 0, y: 50}
            ]
        ]
    },
    
    // Shape #3: Zig-zag gap - diagonal drop-through (two L-shapes)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆâ–ˆ
    // â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    zigZagGap: {
        width: 60,
        height: 80,
        parts: [
            { x: 0, y: 0, w: 60, h: 15 },     // top bar
            { x: 0, y: 15, w: 15, h: 30 },    // left stem
            { x: 45, y: 35, w: 15, h: 30 },   // right stem
            { x: 0, y: 65, w: 60, h: 15 }     // bottom bar
        ],
        // Custom outlines: two L-shapes drawn separately
        outlines: [
            // Top L-shape (top bar + left stem)
            [
                {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 15}, {x: 15, y: 15},
                {x: 15, y: 45}, {x: 0, y: 45}
            ],
            // Bottom inverted-L (right stem + bottom bar)
            [
                {x: 45, y: 35}, {x: 60, y: 35}, {x: 60, y: 80}, {x: 0, y: 80},
                {x: 0, y: 65}, {x: 45, y: 65}
            ]
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2 - SHAPE SHOWCASE (displays all 18 shapes)
    {
        name: "showcase",
        platforms: [
            // Row 1 (y=780): Flat platforms - spawn on first one
            { shape: 'flatLong', x: 150, y: 780 },
            { shape: 'flatMedium', x: 300, y: 780 },
            { shape: 'flatSmall', x: 420, y: 780 },
            { shape: 'flatTiny', x: 520, y: 780 },
            
            // Row 2 (y=680): L-shapes and blocks
            { shape: 'lShapeDownRight', x: 140, y: 680 },
            { shape: 'lShapeDownLeft', x: 280, y: 680 },
            { shape: 'blockTall', x: 400, y: 680 },
            { shape: 'blockWide', x: 500, y: 680 },
            
            // Row 3 (y=570): More blocks and special shapes
            { shape: 'blockShort', x: 140, y: 570 },
            { shape: 'tShape', x: 250, y: 570 },
            { shape: 'pillar', x: 350, y: 570 },
            { shape: 'cupShape', x: 440, y: 570 },
            { shape: 'rock', x: 530, y: 570 },
            
            // Row 4 (y=450): Remaining simple shapes
            { shape: 'bumpyWide', x: 200, y: 450 },
            { shape: 'notchedBlock', x: 400, y: 450 },
            
            // Row 5 (y=320): Compound shapes with gaps
            { shape: 'verticalSlot', x: 150, y: 320 },
            { shape: 'horizontalTunnel', x: 300, y: 320 },
            { shape: 'zigZagGap', x: 480, y: 320 },
            
            // Top platform for reference
            { shape: 'flatLong', x: 350, y: 180 }
        ]
    },
    
    // Layout 3 (was Layout 2)
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 4 (was Layout 3)
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 5 (was Layout 4)
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 5
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

```javascript
/**
 * PlatformShapes.js - Library of hand-crafted platform shapes
 * 
 * SHAPE TYPES:
 * 
 * 1. SIMPLE SHAPES (15 total)
 *    - Defined with `points` array (polygon outline)
 *    - Single collision body matching the shape
 *    - Examples: flatLong, blockTall, lShapeDownRight
 * 
 * 2. COMPOUND SHAPES (3 total)
 *    - Defined with `parts` array (multiple collision rectangles)
 *    - Optional `outlines` array for connected visual appearance
 *    - Have passable gaps/tunnels between collision parts
 *    - Examples: verticalSlot, horizontalTunnel, zigZagGap
 * 
 * SCALING (based on reference with stick figure):
 * - Stick figure: 9x17 pixels (0.75x original)
 * - Flat platforms: ~8px tall
 * - Long platforms: ~100-120px wide
 * - Tall blocks: ~50-80px tall
 * 
 * FUTURE GOALS:
 * - Add more base shapes (5-10 more)
 * - Shape variations: horizontal flip, scaling
 * - Dynamic hole/tunnel system: apply caves/passages to any solid shape
 */

const PLATFORM_SHAPES = {
    
    // === FLAT PLATFORMS (thin, like lines on paper) ===
    
    // Long flat platform (~8-10x character width)
    flatLong: {
        points: [
            {x: 0, y: 0}, {x: 120, y: 0}, {x: 120, y: 8}, {x: 0, y: 8}
        ],
        width: 120,
        height: 8
    },
    
    // Medium flat platform (~5-6x character width)
    flatMedium: {
        points: [
            {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 8}, {x: 0, y: 8}
        ],
        width: 70,
        height: 8
    },
    
    // Small flat platform (~3x character width)
    flatSmall: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 8}, {x: 0, y: 8}
        ],
        width: 40,
        height: 8
    },
    
    // Tiny platform (just wider than character)
    flatTiny: {
        points: [
            {x: 0, y: 0}, {x: 25, y: 0}, {x: 25, y: 8}, {x: 0, y: 8}
        ],
        width: 25,
        height: 8
    },
    
    // === L-SHAPES / STAIRS ===
    
    // L-shape stepping down-right (like in reference)
    lShapeDownRight: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 25},
            {x: 70, y: 25}, {x: 70, y: 35}, {x: 0, y: 35}
        ],
        width: 70,
        height: 35
    },
    
    // L-shape stepping down-left
    lShapeDownLeft: {
        points: [
            {x: 35, y: 0}, {x: 70, y: 0}, {x: 70, y: 35},
            {x: 0, y: 35}, {x: 0, y: 25}, {x: 35, y: 25}
        ],
        width: 70,
        height: 35
    },
    
    // === TALL BLOCKS (like in reference right side) ===
    
    // Tall block (~3x character height)
    blockTall: {
        points: [
            {x: 0, y: 0}, {x: 35, y: 0}, {x: 35, y: 65}, {x: 0, y: 65}
        ],
        width: 35,
        height: 65
    },
    
    // Wide tall block (like the chunky ones in reference)
    blockWide: {
        points: [
            {x: 0, y: 0}, {x: 55, y: 0}, {x: 55, y: 50}, {x: 0, y: 50}
        ],
        width: 55,
        height: 50
    },
    
    // Short thick block
    blockShort: {
        points: [
            {x: 0, y: 0}, {x: 40, y: 0}, {x: 40, y: 30}, {x: 0, y: 30}
        ],
        width: 40,
        height: 30
    },
    
    // === T-SHAPES / SMALL PIECES ===
    
    // T-shape (like the small cross piece in reference)
    tShape: {
        points: [
            {x: 10, y: 0}, {x: 30, y: 0}, {x: 30, y: 15},
            {x: 40, y: 15}, {x: 40, y: 25}, {x: 0, y: 25},
            {x: 0, y: 15}, {x: 10, y: 15}
        ],
        width: 40,
        height: 25
    },
    
    // Small pillar (vertical piece)
    pillar: {
        points: [
            {x: 0, y: 0}, {x: 18, y: 0}, {x: 18, y: 45}, {x: 0, y: 45}
        ],
        width: 18,
        height: 45
    },
    
    // === SPECIAL SHAPES ===
    
    // Cup/D-shape (like the semicircle at top of reference)
    cupShape: {
        points: [
            {x: 5, y: 0}, {x: 25, y: 0}, {x: 30, y: 8},
            {x: 30, y: 20}, {x: 0, y: 20}, {x: 0, y: 8}
        ],
        width: 30,
        height: 20
    },
    
    // Small oval/rock (like bottom center of reference)
    rock: {
        points: [
            {x: 5, y: 0}, {x: 20, y: 0}, {x: 25, y: 8},
            {x: 20, y: 16}, {x: 5, y: 16}, {x: 0, y: 8}
        ],
        width: 25,
        height: 16
    },
    
    // Wide platform with bumpy top (like the wavy one in reference)
    bumpyWide: {
        points: [
            {x: 0, y: 5}, {x: 20, y: 0}, {x: 50, y: 3}, {x: 80, y: 0}, {x: 100, y: 5},
            {x: 100, y: 15}, {x: 0, y: 15}
        ],
        width: 100,
        height: 15
    },
    
    // Notched block (block with bite taken out)
    notchedBlock: {
        points: [
            {x: 0, y: 0}, {x: 50, y: 0}, {x: 50, y: 20},
            {x: 35, y: 20}, {x: 35, y: 35}, {x: 50, y: 35},
            {x: 50, y: 55}, {x: 0, y: 55}
        ],
        width: 50,
        height: 55
    },
    
    // === COMPOUND SHAPES (multiple collision bodies with gaps) ===
    // These have a 'parts' array - both visual AND collision are drawn from parts
    // Each part is a rectangle: { x, y, w, h } relative to shape origin
    
    // Shape #1: Vertical slot - two pillars with drop-through gap
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    // â–ˆâ–ˆ  â–ˆâ–ˆ
    verticalSlot: {
        width: 60,
        height: 60,
        parts: [
            { x: 0, y: 0, w: 20, h: 60 },     // left pillar
            { x: 40, y: 0, w: 20, h: 60 }     // right pillar (20px gap between)
        ]
    },
    
    // Shape #2: Horizontal tunnel - two bars stacked with walk-through gap
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    //           (gap - walk through here)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    horizontalTunnel: {
        width: 70,
        height: 50,
        parts: [
            { x: 0, y: 0, w: 70, h: 15 },     // top bar
            { x: 0, y: 35, w: 70, h: 15 }     // bottom bar
        ],
        // Two separate horizontal bars
        outlines: [
            // Top bar
            [
                {x: 0, y: 0}, {x: 70, y: 0}, {x: 70, y: 15}, {x: 0, y: 15}
            ],
            // Bottom bar
            [
                {x: 0, y: 35}, {x: 70, y: 35}, {x: 70, y: 50}, {x: 0, y: 50}
            ]
        ]
    },
    
    // Shape #3: Zig-zag gap - diagonal drop-through (two L-shapes)
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    // â–ˆâ–ˆ
    // â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    //       â–ˆâ–ˆ
    // â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
    zigZagGap: {
        width: 60,
        height: 80,
        parts: [
            { x: 0, y: 0, w: 60, h: 15 },     // top bar
            { x: 0, y: 15, w: 15, h: 30 },    // left stem
            { x: 45, y: 35, w: 15, h: 30 },   // right stem
            { x: 0, y: 65, w: 60, h: 15 }     // bottom bar
        ],
        // Custom outlines: two L-shapes drawn separately
        outlines: [
            // Top L-shape (top bar + left stem)
            [
                {x: 0, y: 0}, {x: 60, y: 0}, {x: 60, y: 15}, {x: 15, y: 15},
                {x: 15, y: 45}, {x: 0, y: 45}
            ],
            // Bottom inverted-L (right stem + bottom bar)
            [
                {x: 45, y: 35}, {x: 60, y: 35}, {x: 60, y: 80}, {x: 0, y: 80},
                {x: 0, y: 65}, {x: 45, y: 65}
            ]
        ]
    }
};


/**
 * ============================================================================
 * LEVEL LAYOUT DESIGN RULES (for generator reference)
 * ============================================================================
 * 
 * CANVAS & BOUNDARIES:
 * - Canvas: 700x900 pixels
 * - Walls: left at x=55, right at x=645
 * - Water line: y=870
 * - Wall bottoms: y=795 (with horizontal line to page edge)
 * - Playable vertical range: y=120 to y=780
 * 
 * THREE-ZONE STRUCTURE:
 * The map is divided into three vertical zones (like the reference image):
 * 
 * 1. LEFT COLUMN (x ~120-145)
 *    - Stacked horizontal platforms forming "tiers"
 *    - Mostly flatLong shapes, some flatMedium
 *    - ~8-9 tiers, spacing ~70-85px between tiers (NOT uniform)
 *    - X position varies slightly per tier (Â±15px wobble)
 *    - Creates a climbable ladder-like structure on left side
 *    - First platform (bottom-left) is player spawn point
 * 
 * 2. RIGHT COLUMN (x ~555-580)
 *    - Mirror concept of left column, but NOT symmetrical
 *    - Same shapes: mostly flatLong, some flatMedium
 *    - ~7-8 tiers (can differ from left count)
 *    - Y positions OFFSET from left column (don't align horizontally)
 *    - X position varies slightly per tier
 * 
 * 3. CENTER ZONE (x ~260-440)
 *    - Open area with scattered SMALL shapes
 *    - Shape types: rock, flatSmall, flatTiny, tShape, pillar, cupShape
 *    - NO large platforms in center
 *    - ~8-10 pieces at varied heights
 *    - Y positions don't align with side tiers
 *    - More sparse/random feel vs the structured sides
 * 
 * DROP CORRIDORS:
 * - ~40px gap between wall and nearest platform edge
 * - Allows player to drop straight down along walls
 * - Left corridor: x=55 to x~100 (clear)
 * - Right corridor: x~600 to x=645 (clear)
 * 
 * VISUAL RHYTHM:
 * - Sides: Dense, stacked, structured (like ladder rungs)
 * - Center: Sparse, scattered, organic
 * - Creates two "halves" with open middle battlefield
 * 
 * ASYMMETRY PRINCIPLES:
 * - Left and right have different tier counts
 * - Left and right y-positions don't align
 * - Different shapes on each side within same tier
 * - Center pieces positioned organically, not on grid
 * 
 * ============================================================================
 */
const LEVEL_LAYOUTS = [
    // Layout 1 - Two-column pattern with open center (varied y positions)
    {
        name: "mix1",
        platforms: [
            // === LEFT COLUMN (left edge at x=100, ~45px gap from wall) ===
            // flatLong(120w)->center@160, flatMedium(70w)->center@135, flatSmall(40w)->center@120
            { shape: 'flatLong', x: 160, y: 780 },    // Tier 1 (spawn)
            { shape: 'flatLong', x: 160, y: 695 },    // Tier 2
            { shape: 'flatLong', x: 160, y: 620 },    // Tier 3
            { shape: 'flatMedium', x: 135, y: 555 },  // Tier 4
            { shape: 'flatLong', x: 160, y: 475 },    // Tier 5
            { shape: 'flatLong', x: 160, y: 400 },    // Tier 6
            { shape: 'flatMedium', x: 135, y: 315 },  // Tier 7
            { shape: 'flatLong', x: 160, y: 240 },    // Tier 8
            { shape: 'flatSmall', x: 120, y: 160 },   // Tier 9 (top)
            
            // === RIGHT COLUMN (right edge at x=600, ~45px gap from wall) ===
            // Using compound shapes with real gaps!
            // zigZagGap(90w)->center@555, verticalSlot(70w)->center@565, horizontalTunnel(70w)->center@565
            { shape: 'flatLong', x: 540, y: 765 },          // Tier 1
            { shape: 'zigZagGap', x: 555, y: 670 },         // Tier 2 - zig-zag with drop gap!
            { shape: 'flatMedium', x: 565, y: 550 },        // Tier 3
            { shape: 'horizontalTunnel', x: 565, y: 460 },  // Tier 4 - walk-through tunnel!
            { shape: 'flatLong', x: 540, y: 370 },          // Tier 5
            { shape: 'verticalSlot', x: 565, y: 280 },      // Tier 6 - vertical drop slot!
            { shape: 'flatSmall', x: 580, y: 180 },         // Tier 7 (top)
            
            // === CENTER (spread wider, varied y) ===
            { shape: 'rock', x: 280, y: 730 },
            { shape: 'flatSmall', x: 420, y: 650 },
            { shape: 'tShape', x: 300, y: 570 },
            { shape: 'flatTiny', x: 400, y: 500 },
            { shape: 'flatSmall', x: 260, y: 420 },
            { shape: 'pillar', x: 440, y: 350 },
            { shape: 'cupShape', x: 320, y: 270 },
            { shape: 'flatTiny', x: 380, y: 190 },
            { shape: 'rock', x: 350, y: 120 }
        ]
    },
    
    // Layout 2 - SHAPE SHOWCASE (displays all 18 shapes)
    {
        name: "showcase",
        platforms: [
            // Row 1 (y=780): Flat platforms - spawn on first one
            { shape: 'flatLong', x: 150, y: 780 },
            { shape: 'flatMedium', x: 300, y: 780 },
            { shape: 'flatSmall', x: 420, y: 780 },
            { shape: 'flatTiny', x: 520, y: 780 },
            
            // Row 2 (y=680): L-shapes and blocks
            { shape: 'lShapeDownRight', x: 140, y: 680 },
            { shape: 'lShapeDownLeft', x: 280, y: 680 },
            { shape: 'blockTall', x: 400, y: 680 },
            { shape: 'blockWide', x: 500, y: 680 },
            
            // Row 3 (y=570): More blocks and special shapes
            { shape: 'blockShort', x: 140, y: 570 },
            { shape: 'tShape', x: 250, y: 570 },
            { shape: 'pillar', x: 350, y: 570 },
            { shape: 'cupShape', x: 440, y: 570 },
            { shape: 'rock', x: 530, y: 570 },
            
            // Row 4 (y=450): Remaining simple shapes
            { shape: 'bumpyWide', x: 200, y: 450 },
            { shape: 'notchedBlock', x: 400, y: 450 },
            
            // Row 5 (y=320): Compound shapes with gaps
            { shape: 'verticalSlot', x: 150, y: 320 },
            { shape: 'horizontalTunnel', x: 300, y: 320 },
            { shape: 'zigZagGap', x: 480, y: 320 },
            
            // Top platform for reference
            { shape: 'flatLong', x: 350, y: 180 }
        ]
    },
    
    // Layout 3 (was Layout 2)
    {
        name: "mix2",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'rock', x: 300, y: 785 },
            { shape: 'flatLong', x: 520, y: 800 },
            // Lower-mid
            { shape: 'blockTall', x: 140, y: 700 },
            { shape: 'bumpyWide', x: 340, y: 710 },
            { shape: 'flatSmall', x: 560, y: 695 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'cupShape', x: 280, y: 585 },
            { shape: 'flatMedium', x: 420, y: 605 },
            { shape: 'blockShort', x: 570, y: 585 },
            // Upper-mid
            { shape: 'lShapeDownRight', x: 140, y: 490 },
            { shape: 'flatLong', x: 360, y: 475 },
            { shape: 'flatTiny', x: 570, y: 465 },
            // Upper
            { shape: 'flatMedium', x: 170, y: 375 },
            { shape: 'pillar', x: 380, y: 385 },
            { shape: 'flatSmall', x: 560, y: 360 },
            // Top
            { shape: 'flatSmall', x: 140, y: 260 },
            { shape: 'flatMedium', x: 340, y: 270 },
            { shape: 'lShapeDownLeft', x: 540, y: 260 },
            // Very top
            { shape: 'flatLong', x: 260, y: 155 },
            { shape: 'flatSmall', x: 540, y: 140 }
        ]
    },
    
    // Layout 4 (was Layout 3)
    {
        name: "mix3",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatLong', x: 160, y: 800 },
            { shape: 'lShapeDownLeft', x: 380, y: 775 },
            { shape: 'flatMedium', x: 560, y: 800 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 695 },
            { shape: 'notchedBlock', x: 350, y: 700 },
            { shape: 'pillar', x: 560, y: 715 },
            // Mid
            { shape: 'blockWide', x: 140, y: 595 },
            { shape: 'flatSmall', x: 320, y: 580 },
            { shape: 'flatLong', x: 520, y: 600 },
            // Upper-mid
            { shape: 'flatTiny', x: 140, y: 490 },
            { shape: 'blockShort', x: 300, y: 495 },
            { shape: 'lShapeDownRight', x: 510, y: 490 },
            // Upper
            { shape: 'flatMedium', x: 160, y: 385 },
            { shape: 'flatSmall', x: 360, y: 375 },
            { shape: 'flatMedium', x: 550, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'tShape', x: 330, y: 260 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatMedium', x: 270, y: 155 },
            { shape: 'flatTiny', x: 530, y: 170 }
        ]
    },
    
    // Layout 5 (was Layout 4)
    {
        name: "mix4",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'blockShort', x: 130, y: 780 },
            { shape: 'flatLong', x: 320, y: 800 },
            { shape: 'lShapeDownRight', x: 540, y: 775 },
            // Lower-mid
            { shape: 'flatMedium', x: 150, y: 685 },
            { shape: 'tShape', x: 340, y: 680 },
            { shape: 'flatMedium', x: 540, y: 695 },
            // Mid
            { shape: 'lShapeDownLeft', x: 140, y: 580 },
            { shape: 'rock', x: 340, y: 570 },
            { shape: 'bumpyWide', x: 520, y: 585 },
            // Upper-mid
            { shape: 'flatSmall', x: 140, y: 475 },
            { shape: 'blockTall', x: 330, y: 490 },
            { shape: 'flatMedium', x: 540, y: 475 },
            // Upper
            { shape: 'flatSmall', x: 140, y: 375 },
            { shape: 'cupShape', x: 350, y: 360 },
            { shape: 'flatSmall', x: 560, y: 375 },
            // Top
            { shape: 'flatMedium', x: 180, y: 270 },
            { shape: 'flatSmall', x: 400, y: 260 },
            { shape: 'pillar', x: 570, y: 270 },
            // Very top
            { shape: 'flatSmall', x: 140, y: 155 },
            { shape: 'flatLong', x: 360, y: 170 }
        ]
    },
    
    // Layout 6 (was Layout 5)
    {
        name: "mix5",
        platforms: [
            // Bottom - first platform is spawn
            { shape: 'flatMedium', x: 140, y: 800 },
            { shape: 'pillar', x: 320, y: 770 },
            { shape: 'flatMedium', x: 500, y: 800 },
            // Lower-mid
            { shape: 'blockWide', x: 140, y: 700 },
            { shape: 'flatLong', x: 360, y: 695 },
            { shape: 'flatTiny', x: 570, y: 685 },
            // Mid
            { shape: 'flatSmall', x: 140, y: 595 },
            { shape: 'lShapeDownRight', x: 300, y: 595 },
            { shape: 'blockShort', x: 550, y: 585 },
            // Upper-mid
            { shape: 'flatMedium', x: 150, y: 490 },
            { shape: 'flatSmall', x: 350, y: 475 },
            { shape: 'notchedBlock', x: 550, y: 495 },
            // Upper
            { shape: 'lShapeDownLeft', x: 150, y: 385 },
            { shape: 'flatMedium', x: 360, y: 375 },
            { shape: 'flatSmall', x: 560, y: 390 },
            // Top
            { shape: 'flatSmall', x: 140, y: 270 },
            { shape: 'blockShort', x: 340, y: 265 },
            { shape: 'flatMedium', x: 540, y: 285 },
            // Very top
            { shape: 'flatLong', x: 270, y: 170 },
            { shape: 'flatTiny', x: 540, y: 155 }
        ]
    }
];

```

Done! Now we have **6 layouts**:

1. **Layout 1** - Three-zone pattern (tuned)
2. **Layout 2** - **SHAPE SHOWCASE** (NEW - displays all 18 shapes in rows)
3. **Layout 3** - mix2
4. **Layout 4** - mix3
5. **Layout 5** - mix4
6. **Layout 6** - mix5

Press **G** to cycle to Layout 2 and see all shapes displayed:
- Row 1: flat platforms
- Row 2: L-shapes and blocks
- Row 3: blocks and special shapes
- Row 4: bumpyWide and notchedBlock
- Row 5: compound shapes (verticalSlot, horizontalTunnel, zigZagGap)

---

**User**

it seemed like that may have been hard for you to do. perhaps we should take a break from new features and refactor? prior to that maybe checkpoint again, git, context mgmt system, etc

---

**Cursor**

Good call! Let's checkpoint everything properly. I'll update the context files, then you can commit to git.

```markdown
# Current Context for New Chat

## Project Status: Layout System Complete, Ready for Refactor

A stick figure arena shooter built with Phaser 3, styled to look like doodles on crumpled notebook paper. Layout system, compound shapes, and visual style all working. Ready for refactoring before adding more features.

## What Works

- **Player movement:** Arrow keys to move left/right, up to jump
- **Shooting:** Click to fire toward mouse cursor
- **Enemies:** Red stick figures, destroyed when shot
- **Level progression:** 6 layouts that cycle with G key
- **Platform shape library:** 15 simple shapes + 3 compound shapes = 18 total
- **Compound shape system:** Multiple collision bodies + custom visual outlines
- **Shape showcase:** Layout 2 displays all 18 shapes for reference
- **Water hazard:** Blue wavy line with crayon fill at y=870
- **Walls:** Hand-drawn with crayon fill, ending at y=795
- **Crayon visual style:** 24% gray fill + diagonal hatching on all shapes
- **Debug controls:** R (restart), G (next layout), F (fly), H (hitboxes)

## Shape Library (18 shapes)

### Simple Shapes (15)
**Flat:** flatLong (120x8), flatMedium (70x8), flatSmall (40x8), flatTiny (25x8)
**L-shapes:** lShapeDownRight (70x35), lShapeDownLeft (70x35)
**Blocks:** blockTall (35x65), blockWide (55x50), blockShort (40x30)
**Special:** tShape (40x25), pillar (18x45), cupShape (30x20), rock (25x16), bumpyWide (100x15), notchedBlock (50x55)

### Compound Shapes (3)
**verticalSlot** (60x60) - Two pillars, drop-through gap
**horizontalTunnel** (70x50) - Two bars, walk-through gap  
**zigZagGap** (60x80) - Two L-shapes, diagonal drop passage

## Layouts (6 total)

1. **Layout 1** - Three-zone pattern (tuned to reference)
2. **Layout 2** - Shape showcase (all 18 shapes displayed)
3-6. **Layouts 3-6** - Original mixed layouts (need updating)

## Layout Design Rules (for generator)

**Three-Zone Structure:**
- LEFT COLUMN (x ~120-160): Stacked flatLong/flatMedium, edge at x=100
- RIGHT COLUMN (x ~540-580): Similar, edge at x=600  
- CENTER (x ~260-440): Scattered small shapes, compound shapes

**Drop Corridors:** ~45px gap between walls and platform edges

## File Structure

```
stick-game-test/
â”œâ”€â”€ index.html
â”œâ”€â”€ js/
â”‚   â”œâ”€â”€ game.js                   # Phaser config (700x900)
â”‚   â”œâ”€â”€ platforms/
â”‚   â”‚   â””â”€â”€ PlatformShapes.js     # 18 shapes + 6 layouts (~500 lines)
â”‚   â””â”€â”€ scenes/
â”‚       â””â”€â”€ PlayScene.js          # Main gameplay (~780 lines)
â”œâ”€â”€ assets/
â”‚   â””â”€â”€ cropped-notebook-page.png
â”œâ”€â”€ reference/
â”‚   â”œâ”€â”€ example-map.png
â”‚   â””â”€â”€ layout-ref-1.png
â””â”€â”€ ai-context-management/
```

## Technical Notes

- Phaser 3.70.0 via CDN
- Canvas: 700x900
- Walls: x=55 (left), x=645 (right), end y=795
- Water: y=870
- Character: 9x17 pixels
- Run: `python3 -m http.server 8000`

## Suggested Refactoring

**PlayScene.js is getting large (~780 lines).** Consider splitting:
- Shape drawing logic â†’ separate module
- Debug controls â†’ separate module
- Wall/water drawing â†’ separate module

**PlatformShapes.js** - Consider:
- Separating shape definitions from layout definitions
- Adding shape metadata (categories, recommended zones)

## Future Goals (Queued)

1. Add more base shapes (5-10 more)
2. Shape variations (flip, scale)
3. Procedural layout generator
4. Dynamic holes/tunnels system (further out)

## This Session Summary

1. Character size reduced to 0.75x
2. Water simplified, wall bottoms raised
3. Layout 1 redesigned with three-zone structure
4. Created compound shape system
5. Added 3 compound shapes
6. Added crayon-like fill to everything
7. Added debug controls (R/G/F/H)
8. Added shape showcase layout
9. Documented extensively

```

```markdown
# Current Work Focus

Layout system complete with 18 shapes and 6 layouts. Visual style polished. Good stopping point. Consider refactoring before adding more features.

- **Project Goal:** Build a browser-based stick figure arena shooter with random level generation (Worms-style vibes, notebook paper aesthetic)

- **Intermediate Goal:** Refactor codebase, then expand shape library and build procedural generator

- **Current Task:** Checkpoint complete. Next: refactor PlayScene.js (780 lines) into smaller modules, then continue with more shapes and generator.

## Potential Refactoring

1. **Split PlayScene.js:**
   - Shape/platform drawing â†’ `js/drawing/ShapeRenderer.js`
   - Wall/water drawing â†’ `js/drawing/EnvironmentRenderer.js`
   - Debug controls â†’ `js/utils/DebugControls.js`

2. **Split PlatformShapes.js:**
   - Shape definitions â†’ `js/platforms/ShapeDefinitions.js`
   - Layout definitions â†’ `js/platforms/LayoutDefinitions.js`

## Queued Features (After Refactor)

1. Add more base shapes (5-10)
2. Shape variations (flip, scale)
3. Procedural layout generator
4. Dynamic holes/tunnels system

```

Context files updated. Here's what changed:

**Modified files:**
- `js/scenes/PlayScene.js` - Compound shapes, crayon fill, debug controls
- `js/platforms/PlatformShapes.js` - Compound shapes, showcase layout, 6 total layouts
- Context management files - Updated documentation

**New files:**
- `reference/layout-ref-1.png` - Your screenshot

Want me to commit these? Here's a suggested commit message:

```
feat: compound shapes, crayon fill, debug controls, shape showcase

- Added compound shape system (parts + outlines for gaps/tunnels)
- Created 3 compound shapes: verticalSlot, horizontalTunnel, zigZagGap
- Added crayon-like fill to platforms, walls, and water
- Added debug controls: R (restart), G (next map), F (fly), H (hitboxes)
- Added shape showcase layout (Layout 2) displaying all 18 shapes
- Tuned Layout 1 with three-zone structure
- Updated character size to 0.75x, simplified water, raised walls
```

Should I run the git add and commit?

```plaintext
feat: compound shapes, crayon fill, debug controls, shape showcase

- Added compound shape system (parts + outlines for gaps/tunnels)
- Created 3 compound shapes: verticalSlot, horizontalTunnel, zigZagGap
- Added crayon-like fill to platforms, walls, and water
- Added debug controls: R (restart), G (next map), F (fly), H (hitboxes)
- Added shape showcase layout (Layout 2) displaying all 18 shapes
- Tuned Layout 1 with three-zone structure
- Updated character size to 0.75x, simplified water, raised walls
```

---

**User**

yes

---

**Cursor**

Committed! `c886598`

**Checkpoint complete.** Everything's saved:
- Git commit with all changes
- Context management files updated
- Work focus documented

---

**When you're ready to continue, here are the refactoring options:**

1. **Split PlayScene.js (~780 lines)** into:
   - `ShapeRenderer.js` - `createSketchyShape`, `drawCrayonFill`
   - `EnvironmentRenderer.js` - Wall/water drawing
   - `DebugControls.js` - R/G/F/H key handlers

2. **Split PlatformShapes.js** into:
   - `ShapeDefinitions.js` - The 18 shapes
   - `LayoutDefinitions.js` - The 6 layouts

Or if you'd prefer to take a break and come back fresh, the context files are ready for a new chat anytime. Just paste the contents of `paste-this-into-new-ai-chats.txt` to get started.

---

**User**

@ai-agent-stale-chat-procedures.md (1-78) lets refactor after we handle this. we may have done most of the stuff in this procedure just now already

---

**Cursor**

You're right - we just did most of it! Let me check what's left:

**Already done âœ…**
- Updated `current-context-for-new-chat.md` - full session summary
- Updated `current-work-focus.md` - next steps documented
- Committed everything to git

**Potentially remaining:**
- **Chat export to `past-chat-record/`** - Do you want to export this chat yourself using the guides, or would you like me to create a summary file there?

The context files are already prepped for a new chat. The only question is whether you want this conversation preserved in `past-chat-record/` before starting fresh.

**So: A) Refresh & continue this chat, or B) Start fresh?**

(If B, do you want to export the chat yourself or should I write a summary to `past-chat-record/`?)

